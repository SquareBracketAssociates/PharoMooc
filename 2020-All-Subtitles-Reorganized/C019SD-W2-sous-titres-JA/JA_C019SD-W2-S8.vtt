WEBVTT

00:00:00.560 --> 00:00:04.240 align:middle
このコースでは
Pharo での真偽値と条件分岐について学びます。

00:00:04.960 --> 00:00:09.160 align:middle
真偽値を表すオブジェクトが2つあります。
true と false です。

00:00:09.320 --> 00:00:12.480 align:middle
true は True クラスの唯一のインスタンスです。

00:00:12.640 --> 00:00:15.440 align:middle
false は False クラスの唯一のインスタンスです。

00:00:15.600 --> 00:00:20.640 align:middle
論理演算をするためには
これらのオブジェクトにメッセージを送ります。

00:00:20.800 --> 00:00:24.160 align:middle
あるいは ifTrue:ifFalse: 等のような
分岐構造をつくります。

00:00:24.320 --> 00:00:26.280 align:middle
これを学びましょう。

00:00:26.920 --> 00:00:29.880 align:middle
このスライドの最初の例では

00:00:30.040 --> 00:00:34.240 align:middle
二項演算子として & メッセージを

00:00:34.400 --> 00:00:35.720 align:middle
false オブジェクトに送っています。

00:00:35.880 --> 00:00:38.520 align:middle
引数として
これ全てを渡します。

00:00:38.680 --> 00:00:42.320 align:middle
括弧で囲まれた表現式です。
(1 error:'crazy')

00:00:42.480 --> 00:00:45.480 align:middle
この式はエラーを発生させます。

00:00:45.640 --> 00:00:50.280 align:middle
この式全体がエラーを起こすことがわかります。

00:00:50.440 --> 00:00:53.600 align:middle
なぜかというと
オペランドが評価されたからです。

00:00:53.760 --> 00:00:56.280 align:middle
この論理式の中で。

00:00:57.560 --> 00:01:01.000 align:middle
オペランドが評価されたから
失敗するのです。

00:01:01.160 --> 00:01:05.640 align:middle
論理式の遅延評価が必要であれば

00:01:05.800 --> 00:01:10.960 align:middle
Booleanクラスのメソッドである
and: を使わなければなりません。

00:01:11.120 --> 00:01:13.440 align:middle
このメソッドはブロックを引数として取ります。

00:01:13.600 --> 00:01:18.000 align:middle
ブロックは [ で始まって ] で終わります。

00:01:18.160 --> 00:01:21.320 align:middle
ブロックは表現式を持ちますが
ブロック式を定義しただけでは

00:01:21.480 --> 00:01:24.800 align:middle
その表現式は実行されません。

00:01:24.960 --> 00:01:28.640 align:middle
今のところは
これらの表現式は評価されません。

00:01:28.800 --> 00:01:31.600 align:middle
第一オペランドが true か false か
評価された時にのみ

00:01:32.320 --> 00:01:35.600 align:middle
引数として渡されたブロックが評価されます。

00:01:35.760 --> 00:01:39.880 align:middle
2番目の例では
false and: ブロック となっています。

00:01:40.040 --> 00:01:45.440 align:middle
引数として渡されたブロックを評価することなしに
false を返します。

00:01:45.960 --> 00:01:49.360 align:middle
典型的な遅延演算子ですが
ブロックを使って作られています。

00:01:51.400 --> 00:01:55.160 align:middle
Pharo では if、false、while等といった
条件分岐は

00:01:55.320 --> 00:01:59.160 align:middle
真偽値やブロックに送られるメッセージです。

00:02:00.080 --> 00:02:01.800 align:middle
別の例を見てみましょう。

00:02:01.960 --> 00:02:06.960 align:middle
ifTrue:ifFalse: メッセージです。
あらゆるプログラミング言語に典型的なものです。

00:02:07.120 --> 00:02:09.280 align:middle
しかし Pharo では
これは実際にはメッセージなのです。

00:02:09.440 --> 00:02:13.440 align:middle
真偽値オブジェクトに
ifTrue:ifFalse: メッセージを送ります。

00:02:13.600 --> 00:02:16.480 align:middle
この式は真偽値を返します。

00:02:17.840 --> 00:02:22.760 align:middle
メッセージの引数として2つのブロックを渡します。

00:02:22.920 --> 00:02:26.560 align:middle
1つのブロックは
レシーバーの真偽値が true の場合に評価されます。

00:02:26.720 --> 00:02:29.480 align:middle
もう1つのブロックは
レシーバーが false の場合に評価されます。

00:02:30.560 --> 00:02:33.200 align:middle
注意してください。
ifTrue:ifFalse: メッセージは

00:02:33.360 --> 00:02:37.000 align:middle
Pharo ではとてもよく使われています。
システムの心臓部なのです。

00:02:37.160 --> 00:02:42.320 align:middle
とても重要なので
システム全体が遅くならないよう

00:02:42.480 --> 00:02:46.480 align:middle
実行効率のために高度に最適化されています。

00:02:47.800 --> 00:02:51.160 align:middle
Pharo での真偽値の実装の話に戻りましょう。

00:02:51.320 --> 00:02:53.360 align:middle
極めてエレガントです。

00:02:53.520 --> 00:02:59.000 align:middle
true および false というオブジェクトは
それぞれ True クラスと False クラスのインスタンスで

00:02:59.160 --> 00:03:01.400 align:middle
いずれのクラスも
Boolean クラスを継承しています。

00:03:01.560 --> 00:03:04.760 align:middle
これらのクラスはそれぞれ
期待された振る舞いをするように

00:03:04.920 --> 00:03:07.640 align:middle
一揃いのメソッドが実装されています。

00:03:07.800 --> 00:03:13.080 align:middle
このエレガントな実装については
別のレッスンで

00:03:13.240 --> 00:03:15.200 align:middle
掘り下げてみましょう。

00:03:16.640 --> 00:03:19.560 align:middle
ifTrue:ifFalse: メッセージの話に戻ります。

00:03:19.720 --> 00:03:23.200 align:middle
このメッセージには色々なバージョンがあります。

00:03:23.360 --> 00:03:28.040 align:middle
1つのブロックを引数にとる ifTrue: のみからなる
バージョンもあり

00:03:28.960 --> 00:03:31.760 align:middle
分岐の最初の部分だけを返します。

00:03:31.920 --> 00:03:34.960 align:middle
ifTrue:ifFalse:メッセージは
2つのブロックを取り

00:03:35.120 --> 00:03:39.480 align:middle
真偽値が true か false かによって
分岐のいずれかを返します。

00:03:40.520 --> 00:03:43.720 align:middle
ここにいくつかの例があります。

00:03:43.880 --> 00:03:46.480 align:middle
これは ifTrue: メッセージを送り

00:03:46.640 --> 00:03:49.960 align:middle
ブロックを1つだけ渡して
表現式が true の場合のみ実行されます。

00:03:50.120 --> 00:03:53.080 align:middle
この例では
評価されるブロックは1つです。

00:03:53.240 --> 00:03:55.920 align:middle
もしレシーバーの真偽値が true ならば
こちらのブロックが

00:03:56.080 --> 00:03:58.320 align:middle
もし false ならば
こちらのブロックが実行されます。

00:04:00.960 --> 00:04:02.960 align:middle
これらはそれぞれ別々のメッセージです。

00:04:03.120 --> 00:04:05.120 align:middle
ifFalse: も同様で

00:04:05.280 --> 00:04:08.760 align:middle
Boolean、True、Falseといったクラス
で扱われます。

00:04:10.400 --> 00:04:15.560 align:middle
条件分岐を表現するための
他の種類のメッセージも用意されています。

00:04:15.720 --> 00:04:18.360 align:middle
例えば、
ifEmpty:ifNotEmpty: という

00:04:18.520 --> 00:04:20.600 align:middle
コレクションに送るメッセージです。

00:04:20.760 --> 00:04:23.920 align:middle
ifEmpty: にブロックを渡します。

00:04:24.920 --> 00:04:29.200 align:middle
レシーバーのコレクションが空の場合にのみ
ブロックが実行されます。

00:04:29.960 --> 00:04:34.480 align:middle
ifNotEmpty: はそれとは逆の条件です。

00:04:34.640 --> 00:04:38.240 align:middle
もしコレクションが空でなければ
ブロックが実行されます。

00:04:38.400 --> 00:04:40.920 align:middle
もう1点。

00:04:41.080 --> 00:04:45.080 align:middle
このブロックは引数を1つ取ります。

00:04:45.240 --> 00:04:47.680 align:middle
渡されるのは空ではないコレクションです。

00:04:47.840 --> 00:04:51.880 align:middle
このコレクションは
何か複雑な計算をした結果かもしれません。

00:04:52.040 --> 00:04:54.520 align:middle
そのコレクションを得るために
もう一度そのクエリーを実行することもできます。

00:04:54.680 --> 00:04:58.600 align:middle
もしコレクションが空ではない場合
ブロックに引数として渡されます。

00:04:58.760 --> 00:05:01.320 align:middle
そして渡されたコレクションを
ブロックの表現式の中で使うことができます。

00:05:02.160 --> 00:05:03.920 align:middle
このセッションでは

00:05:04.080 --> 00:05:06.800 align:middle
Pharo では真偽値は通常のオブジェクトであり

00:05:06.960 --> 00:05:10.800 align:middle
Booleanクラスを継承するTrueクラスとFalseクラスの
インスタンスであることを学びました。

00:05:10.960 --> 00:05:12.560 align:middle
それらの真偽値にメッセージを送ることができます。

00:05:12.720 --> 00:05:18.240 align:middle
それらのメッセージは
Pharo での条件分岐や条件式を

00:05:18.400 --> 00:05:21.520 align:middle
構成するために定義されています。

00:05:21.680 --> 00:05:26.440 align:middle
他の言語ではそういった構造はコンパイラに依っています。

