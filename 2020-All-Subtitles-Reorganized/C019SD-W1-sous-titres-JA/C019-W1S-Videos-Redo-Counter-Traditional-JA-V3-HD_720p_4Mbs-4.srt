1
00:00:01,190 --> 00:00:03,000
このビデオで紹介するのは

2
00:00:03,167 --> 00:00:05,220
パッケージやクラスを作って
テストを記述する方法です。

3
00:00:05,770 --> 00:00:09,100
まず最初に
システムブラウザを開きます。

4
00:00:09,530 --> 00:00:11,710
システムブラウザを使って
パッケージをブラウズすることができます。

5
00:00:11,877 --> 00:00:12,590
ここにあるのがパッケージです。

6
00:00:14,260 --> 00:00:16,600
最初に、パッケージを作ります。

7
00:00:16,830 --> 00:00:21,790
「Add package」をクリックして、
「MyCounter」と。

8
00:00:22,280 --> 00:00:23,640
パッケージは沢山あるので
全部を見たくはありません。

9
00:00:23,807 --> 00:00:27,050
パッケージをフィルターするといいでしょう。

10
00:00:27,950 --> 00:00:30,000
私たちの 「MyCounter」パッケージがあります。

11
00:00:30,157 --> 00:00:32,740
そして、クラスを定義します。

12
00:00:32,907 --> 00:00:37,550
「Counter」です。
インスタンス変数は「count」です。

13
00:00:38,140 --> 00:00:42,290
ここがオレンジ色になっているのは
コードがまだセーブされていないことを示しています。

14
00:00:42,610 --> 00:00:45,690
ここで、「Accept」機能で
コードをコンパイルします。

15
00:00:46,290 --> 00:00:49,570
さあこれで Counter クラスが
コンパイルされました。

16
00:00:49,830 --> 00:00:51,920
システムが調べて

17
00:00:53,200 --> 00:00:56,290
アドバイスしてきます。これは後で説明します。
とりあえず今は気にしなくて結構です。

18
00:01:00,790 --> 00:01:03,690
赤い「!」記号がありますが
これはコメントを書いていないからです。

19
00:01:03,857 --> 00:01:05,280
では、書いてみましょう。

20
00:01:05,447 --> 00:01:12,330
コメントは

21
00:01:12,497 --> 00:01:13,880
「I'm a simple counter…」
（私は簡単なカウンタです…）

22
00:01:45,790 --> 00:01:49,230
簡単な例題を書いてみましょう
そうするとカウンターは自分が

23
00:01:49,397 --> 00:01:53,050
どう動作するかわかるようになります。
Counter new

24
00:01:55,750 --> 00:02:00,120
Counter increment increment
Counter

25
00:02:02,920 --> 00:02:07,500
count. これで 2 になるはずです。

26
00:02:09,880 --> 00:02:14,180
またもや、テキストはまだセーブされていません。
コンパイルします。

27
00:02:14,347 --> 00:02:16,540
これでセーブされました。

28
00:02:16,850 --> 00:02:20,050
では、アクセサを定義しましょう。

29
00:02:21,940 --> 00:02:24,770
アクセサは一般的には
accessingプロトコルに入れます。

30
00:02:26,640 --> 00:02:31,540
countはcountをリターンする、と書きます。

31
00:02:33,160 --> 00:02:35,720
同じように、aNumberを引数にして

32
00:02:38,220 --> 00:02:40,740
セッターを書きます。

33
00:02:46,190 --> 00:02:48,380
おわかりのように
私はcountメソッドを修正ました。


34
00:02:48,547 --> 00:02:50,770
countメソッドが無くなってしまった
ように思うかもしれませんが、大丈夫です。

35
00:02:50,937 --> 00:02:54,120
メソッドを変更する時に
違うメソッド名になっていると

36
00:02:54,287 --> 00:02:55,320
新しいメソッドが作られます。

37
00:02:55,487 --> 00:02:58,530
新しいメソッドをコンパイルすると、
count はちゃんとここにあります。

38
00:03:01,160 --> 00:03:05,190
ここで、テストとして
小さなプログラムを書いてみましょう。

39
00:03:07,360 --> 00:03:08,000
Playground を開きます。

40
00:03:09,910 --> 00:03:14,700
カウンタを作って、と。
次の行で

41
00:03:14,867 --> 00:03:19,730
値を入れます。

42
00:03:21,000 --> 00:03:25,420
C count: 7と。
ここで値を訊いてみると

43
00:03:25,587 --> 00:03:29,600
何を返してくるでしょうか？
「7」が返ってきます.

44
00:03:32,400 --> 00:03:34,390
さて、ここで本当に書きたいのは

45
00:03:34,557 --> 00:03:38,460
テストです。
この書き方では実行できません。

46
00:03:39,040 --> 00:03:40,350
自動的に実行できるようにしたいのです。

47
00:03:40,630 --> 00:03:42,910
テストケースを作ります。

48
00:03:43,077 --> 00:03:44,820
Pharo ではどうやって
テストクラスを作るのでしょうか？

49
00:03:45,000 --> 00:03:48,450
スーパークラスを変更して、
継承元を

50
00:03:50,220 --> 00:03:55,000
TestCase にします。
これでテストクラスとしてCounterTestを

51
00:03:55,167 --> 00:03:56,140
定義します。

52
00:03:56,910 --> 00:03:59,860
これをコンパイルします。

53
00:04:00,660 --> 00:04:03,700
システムに新しく CounterTest クラスが
できました。

54
00:04:04,570 --> 00:04:08,410
新しいメソッドを定義しましょう。
プロトコルを追加します。

55
00:04:08,577 --> 00:04:10,030
tests プロトコルです.

56
00:04:11,620 --> 00:04:14,300
ここで新しいメソッドを定義します。

57
00:04:14,467 --> 00:04:17,940
Tests のメソッド名は
「test」で始まらなければなりません。

58
00:04:18,107 --> 00:04:21,690
そして TestCase クラスから継承している
必要があります。

59
00:04:22,380 --> 00:04:23,580
メソッド名は
testCounterisSetAndRead

60
00:04:31,170 --> 00:04:35,590
とでもしましょう。
これでほとんど完成したようなものです。

61
00:04:35,757 --> 00:04:36,540
必要なことはほとんど書きました。

62
00:04:37,620 --> 00:04:40,330
インデントを整えて

63
00:04:40,497 --> 00:04:41,730
カウンタを作って

64
00:04:42,580 --> 00:04:45,680
ここで
self assert

65
00:04:49,750 --> 00:04:54,200
equals 7
この文は

66
00:04:54,367 --> 00:04:58,560
self assert C count = 7
と全く同じです。

67
00:05:01,870 --> 00:05:04,640
ただし、1つ目の文のほうが便利です。
返ってきた値が間違っていた場合に

68
00:05:04,807 --> 00:05:08,470
もっと賢い報告をしてくれます。

69
00:05:08,637 --> 00:05:10,910
コンパイルします。

70
00:05:12,790 --> 00:05:17,690
これでテストを実行して、

71
00:05:19,790 --> 00:05:22,440
テストはグリーンです。
テストがあり、そしてグリーンなので

72
00:05:22,607 --> 00:05:26,180
あなたの製品、つまりコードを
セーブするのに良いタイミングです。

73
00:05:26,370 --> 00:05:27,930
Pharo では、イメージをセーブします。

74
00:05:28,097 --> 00:05:30,080
ここではイメージをセーブしますが

75
00:05:30,247 --> 00:05:31,320
イメージのセーブで満足ではありません。

76
00:05:32,770 --> 00:05:35,040
そこでコードを

77
00:05:35,207 --> 00:05:36,820
バージョン管理システムに保存します。

78
00:05:37,070 --> 00:05:39,960
ここで、私はあなたがインターネットに
アクセスきでるかわかりませんので

79
00:05:40,127 --> 00:05:44,610
ローカルなキャッシュを使います。

80
00:05:44,777 --> 00:05:48,860
おわかりでしょうか。
このディレクトリには

81
00:05:49,027 --> 00:05:52,930
全てのパッケージが表示されていて

82
00:05:54,000 --> 00:05:55,360
どれがロードされていて
どれがロードされていないか判ります。

83
00:05:55,770 --> 00:05:58,490
ここに、変更が保存されていないパッケージが

84
00:05:58,657 --> 00:06:02,870
表示されています。

85
00:06:03,070 --> 00:06:05,060
最初の2つは気にしなくていいです。

86
00:06:05,227 --> 00:06:09,160
MyPackage に星印がついています。
これは、イメージの中のコードが

87
00:06:09,327 --> 00:06:10,760
まだ保存されていないことを示しています。

88
00:06:12,130 --> 00:06:14,020
では保存しましょう。
Saveをクリックして

89
00:06:14,187 --> 00:06:15,230
レポジトリを選択します。

90
00:06:16,520 --> 00:06:17,320
saveをクリックします。

91
00:06:21,400 --> 00:06:26,180
"first version with accessors and a
（アクセサ付きで、

92
00:06:27,210 --> 00:06:29,090
green test".
テストがグリーンの最初のバージョン）

93
00:06:32,640 --> 00:06:35,600
acceptします。
これで1つのパッケージを保存しました。

94
00:06:35,800 --> 00:06:36,530
確認しましょう。

95
00:06:36,697 --> 00:06:41,370
このディレクトリを開きます。
すると、システムにロードされた

96
00:06:42,410 --> 00:06:44,460
沢山のパッケージが入っています。

97
00:06:44,627 --> 00:06:48,470
フィルタすると、

98
00:06:48,637 --> 00:06:51,130
さきほどのパッケージとそのバージョンが
見つかります。

99
00:06:57,620 --> 00:07:00,740
新しい機能を追加するたびに
保存することを助言します。

100
00:07:00,907 --> 00:07:03,460
これからそうしましょう。

101
00:07:06,770 --> 00:07:09,900
さあ、ここで新しいテストを

102
00:07:10,067 --> 00:07:12,130
実装の前に作ってみましょう。

103
00:07:12,410 --> 00:07:14,590
これからテストを書きます。

104
00:07:14,757 --> 00:07:19,710
カウンターのインクリメントについて

105
00:07:19,877 --> 00:07:21,200
「TestIncrement」
何を書きましょう？

106
00:07:21,367 --> 00:07:22,000
書きたい内容は

107
00:07:26,330 --> 00:07:27,430
カウンターを作って

108
00:07:33,510 --> 00:07:38,400
デフォルト値を代入して

109
00:07:38,840 --> 00:07:43,410
このカウンタを2回インクリメントします。

110
00:07:44,100 --> 00:07:45,310
何をチェックすべきでしょうか？

111
00:07:45,477 --> 00:07:48,130
カウンターが

112
00:07:51,150 --> 00:07:51,870
正しい値かをチェックします。

113
00:07:57,900 --> 00:08:02,800
コンパイルします。テストは

114
00:08:03,000 --> 00:08:06,880
レッドです。まだカウンターを
実装していませんから。

115
00:08:07,510 --> 00:08:10,390
インクリメントとデクリメントは
カウンターの操作(operations)です。

116
00:08:11,520 --> 00:08:12,450
operationsを追加します。
increment。

117
00:08:21,660 --> 00:08:22,390
何をしましょう？

118
00:08:22,557 --> 00:08:26,890
self
count 2: self count + 1

119
00:08:27,200 --> 00:08:30,270
アクセサーを使うかどうかは

120
00:08:30,437 --> 00:08:32,080
状況次第で
スタイルの問題です。

121
00:08:34,510 --> 00:08:37,630
decrementも

122
00:08:39,710 --> 00:08:40,500
同じように定義します。

123
00:08:42,380 --> 00:08:44,470
incrementについては
テストがあるので

124
00:08:44,637 --> 00:08:48,190
実行できます。
テストはグリーンです。

125
00:08:48,357 --> 00:08:50,370
これで2つのテストがちゃんと動きます。

126
00:08:50,710 --> 00:08:53,350
テストクラスを見れば
全てのテストがグリーンです。

127
00:08:53,670 --> 00:08:54,540
何をしましょう？

128
00:08:54,707 --> 00:08:56,790
保存します。新規保存します。

129
00:08:56,957 --> 00:09:00,340
「incrementとdecrementを追加した」
と書きます。

130
00:09:13,110 --> 00:09:17,850
さあ、これで
2つのバージョンができました。

131
00:09:23,250 --> 00:09:23,883
パッケージのバージョンです。

132
00:09:24,090 --> 00:09:29,020
「decrement」のテストも書きます。

133
00:09:29,187 --> 00:09:30,100
書かない理由がありませんから。

134
00:09:31,700 --> 00:09:36,590
「Decrement」
例えば

135
00:09:36,757 --> 00:09:40,320
値を2として

136
00:09:40,487 --> 00:09:43,890
2回decrementしたら
0になるはずです。

137
00:09:44,057 --> 00:09:48,550
テストはグリーンです。

138
00:09:49,570 --> 00:09:50,203
なので、保存します。

139
00:10:06,490 --> 00:10:10,490
ここで、欲しい機能があります。

140
00:10:10,657 --> 00:10:14,300
「Counter new」と書いて
「Print it」すると

141
00:10:14,467 --> 00:10:16,910
カウンターが表示されますが
値がわかりません。

142
00:10:17,077 --> 00:10:19,000
あまり便利ではありません。

143
00:10:19,360 --> 00:10:22,260
ここを改良したいと思います。

144
00:10:24,130 --> 00:10:26,630
そこで、メソッドを追加します。

145
00:10:26,797 --> 00:10:29,840
「PrintOn:」です。
「printing」プロトコルに定義します。

146
00:10:31,340 --> 00:10:33,110
「PrintOn:」は

147
00:10:33,277 --> 00:10:34,530
表示するたびにシステムから
利用されます。

148
00:10:35,760 --> 00:10:36,750
引数は「aStream」です。

149
00:10:38,690 --> 00:10:39,440
何をしましょうか？

150
00:10:40,200 --> 00:10:43,170
カウンターだとわかるように

151
00:10:43,337 --> 00:10:47,460
元の機能を使います。

152
00:10:51,740 --> 00:10:54,170
ここで

153
00:10:58,530 --> 00:10:59,850
ちょっと追加して

154
00:11:04,470 --> 00:11:05,103
書きます。

155
00:11:17,370 --> 00:11:20,570
例えば「with value:」（値は）
「self count」

156
00:11:24,150 --> 00:11:27,740
こうすることで
数を

157
00:11:27,907 --> 00:11:32,180
表記できます。

158
00:11:34,260 --> 00:11:35,290
そして「cr」と。

159
00:11:35,457 --> 00:11:36,260
コンパイルします。

160
00:11:42,900 --> 00:11:45,550
システムはもっといい方法があると
言ってきますが、まあいいでしょう。

161
00:11:46,040 --> 00:11:47,270
今回は気にしないでおきます。

162
00:11:48,590 --> 00:11:49,760
「Counter new」と書いてみます。

163
00:11:51,000 --> 00:11:54,740
ほら、値がnilのカウンターだと
表示されました。

164
00:11:54,907 --> 00:11:58,020
これは正常です。
初期化してませんから。

165
00:12:01,260 --> 00:12:04,960
では、初期化に対応しましょう。

166
00:12:07,590 --> 00:12:09,780
まずはテストを書きます。

167
00:12:14,050 --> 00:12:18,020
AtCreationTimeIsZero
（カウンターを生成した時の値は

168
00:12:19,770 --> 00:12:23,180
ゼロ）、と。

169
00:12:24,950 --> 00:12:25,760
さあどうしましょう？

170
00:12:25,927 --> 00:12:27,280
「self assert:」として

171
00:12:27,447 --> 00:12:30,840
チェックするのは「Counter new

172
00:12:33,030 --> 00:12:36,210
count = 0」。 

173
00:12:38,020 --> 00:12:39,010
これでどうでしょうか？

174
00:12:39,177 --> 00:12:41,090
テストは失敗です。なぜでしょう？

175
00:12:41,257 --> 00:12:45,140
これを実行したら
nilが得られるからです。

176
00:12:47,140 --> 00:12:49,820
ここで、Counterはクラスで
CounterTestクラスのインスタンス変数には

177
00:12:50,000 --> 00:12:53,560
アクセスしていないので

178
00:12:53,727 --> 00:12:57,110
この表現式を選択して
直接実行することができます。

179
00:13:00,280 --> 00:13:03,170
このテストはまだ正しくないですが

180
00:13:03,680 --> 00:13:04,420
どうしたらいいでしょうか？

181
00:13:04,587 --> 00:13:09,110
initialisation（初期化）プロトコルに
initializeメソッドを追加します。

182
00:13:16,900 --> 00:13:21,730
そして、このメソッドで
何をしたらいいでしょう？

183
00:13:22,160 --> 00:13:25,760
「super initialize」と書いて
そして

184
00:13:25,927 --> 00:13:27,730
countは0と。

185
00:13:27,897 --> 00:13:31,550
このメソッドは「new」メソッドが
使われるたびに実行されます。

186
00:13:32,330 --> 00:13:35,700
さて、テストを見てみましょう。
グリーンです。

187
00:13:35,867 --> 00:13:40,070
同様に、「Counter new count」は
0になります。

188
00:13:41,010 --> 00:13:45,320
もう一度保存します。
printOnを追加、と。

189
00:13:45,487 --> 00:13:47,490
initializeとテストを追加。

190
00:14:04,000 --> 00:14:06,270
さあ、ここで興味深いのは

191
00:14:06,437 --> 00:14:09,300
ここまでのヒストリーを
見ることができるところです。

192
00:14:09,467 --> 00:14:12,310
さらにこのヒストリーの中を
見てブラウズすることができます。

193
00:14:12,520 --> 00:14:16,180
「version」をクリックすると
これら2つの違いが見れます。

194
00:14:17,960 --> 00:14:20,440
バージョン3とバージョン4の違いは

195
00:14:20,607 --> 00:14:21,530
「initialize」「printOn」とテスト。

196
00:14:22,000 --> 00:14:24,660
バージョン2とバージョン4の

197
00:14:28,490 --> 00:14:33,360
違いを見ます。

198
00:14:33,527 --> 00:14:34,160
これらの変更をみんな見ることができます。

199
00:14:35,870 --> 00:14:38,220
さて、これで
やり残したことは1つです。

200
00:14:38,387 --> 00:14:43,100
オブジェクトを作る方法を
少し変えます。

201
00:14:43,820 --> 00:14:47,210
まず最初にテストを書くことで

202
00:14:47,377 --> 00:14:51,040
何をするのかを明確にします。
テストを定義します。

203
00:14:53,040 --> 00:14:56,000
「AlternateClassCreation」です。

204
00:14:58,000 --> 00:14:59,500
さて、何がしたいのでしょう？

205
00:15:01,000 --> 00:15:03,000
確認したいことは、

206
00:15:05,000 --> 00:15:11,000
「Counter withValue: 19」を

207
00:15:11,500 --> 00:15:13,000
インクリメントして

208
00:15:15,000 --> 00:15:20,000
値を取り出したら
20が返ってくるということです。

209
00:15:21,000 --> 00:15:23,000
よし、と。

210
00:15:30,000 --> 00:15:34,000
ここに括弧を入れましょう。
そのほうがいいです。

211
00:15:38,000 --> 00:15:42,000
テストはまたもや
成功ではありません。

212
00:15:44,000 --> 00:15:48,000
「未知のメッセージを送っています」
と言っています。

213
00:15:49,000 --> 00:15:52,000
「withValue:」というメッセージは

214
00:15:52,200 --> 00:15:55,000
オブジェクトではなく
クラスに送られます。

215
00:15:55,500 --> 00:15:58,500
つまり、このメッセージを

216
00:15:58,600 --> 00:15:59,900
クラスに定義する必要があります。
クラスを選択して

217
00:16:00,000 --> 00:16:03,000
クラスレベルに行って
追加します。

218
00:16:03,200 --> 00:16:10,000
プロトコルは
「instance creation 」

219
00:16:12,500 --> 00:16:16,400
「withValue: aNumber」
さあ、何をすべきでしょう？

220
00:16:17,500 --> 00:16:18,400
最初にすることは

221
00:16:19,000 --> 00:16:21,800
カウンターを生成することです。
変数counterに

223
00:16:22,000 --> 00:16:24,500
…じっくり書いています…

224
00:16:24,600 --> 00:16:26,000
「self new 」
これでカウンターを作って

225
00:16:26,100 --> 00:16:29,900
「self count: aNumber」
と書きます。

226
00:16:30,000 --> 00:16:34,000
そしてこのカウンターを返します。

227
00:16:34,100 --> 00:16:35,000
もっと短く書くこともできますが

228
00:16:35,100 --> 00:16:38,000
とりあえずは単純に書きましょう。

229
00:16:38,100 --> 00:16:40,000
メソッドをコンパイルします。

230
00:16:40,100 --> 00:16:43,000
さて、これでメッセージを送れます。

231
00:16:43,500 --> 00:16:49,000
ほら、このボタンをクリックすると

232
00:16:49,100 --> 00:16:52,000
クラスレベルから

233
00:16:52,100 --> 00:16:53,000
インスタンスレベルに移動します。

234
00:16:53,100 --> 00:16:55,000
これでクラスレベルから

235
00:16:55,100 --> 00:16:57,500
インスタンスへ送られるメッセージ
に戻ってきました。

236
00:16:58,100 --> 00:17:01,200
どういうことでしょう？
つまり

237
00:17:01,500 --> 00:17:08,900
「Counter withValue: 18」
とすると、何が得られるでしょう？

238
00:17:09,000 --> 00:17:11,000
Counterクラスのインスタンスが
得られます。

239
00:17:12,500 --> 00:17:15,000
値が18のカウンターが得られます。

240
00:17:15,100 --> 00:17:18,000
そして、ここで
decrementできます。

241
00:17:21,100 --> 00:17:23,000
リフレッシュすると
17になります。

242
00:17:26,100 --> 00:17:28,900
ここでテストを見れば

243
00:17:29,000 --> 00:17:32,000
全てのテストはOKです。
なので、ここでまた

244
00:17:32,100 --> 00:17:35,000
保存して、これで完了です。

245
00:17:37,100 --> 00:17:44,000
インスタンス生成のAPIと
テストを追加。

246
00:17:45,000 --> 00:17:48,000
今回は以上です。
