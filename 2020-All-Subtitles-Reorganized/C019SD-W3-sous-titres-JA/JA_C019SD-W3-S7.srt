1
00:00:00,960 --> 00:00:05,160
このコースでは
Pharo のコレクションの階層の

2
00:00:05,320 --> 00:00:07,600
要点について学びます。

3
00:00:07,760 --> 00:00:11,760
Pharo には沢山の種類のコレクションが
あることがわかるでしょう。

4
00:00:11,920 --> 00:00:14,960
プログラマを楽にしてくれます。

5
00:00:15,120 --> 00:00:17,360
同じ API を共有しているので。

6
00:00:17,520 --> 00:00:22,720
また、リテラルなコレクションと動的なものの
違いについても見てみます。

7
00:00:23,960 --> 00:00:28,720
コレクションには多くの種類があるので
その API は多種多様ですが

8
00:00:28,880 --> 00:00:32,360
よく整理された共通 API を共有しているので

9
00:00:32,520 --> 00:00:34,880
プログラマを楽にしてくれます。

10
00:00:35,440 --> 00:00:37,880
Pharo 特有なことは

11
00:00:38,040 --> 00:00:41,000
最初の要素のインデックスが 1 だと
いうことです。

12
00:00:41,160 --> 00:00:43,560
0 になっている他の言語と違って。

13
00:00:44,280 --> 00:00:47,880
Pharo では、コレクションは
どんな種類のオブジェクトも格納できます。

14
00:00:48,040 --> 00:00:50,840
他の言語では必ずしもそうではありません。

15
00:00:51,440 --> 00:00:55,240
最も素晴らしく、また、広く使われている
コレクションをいくつか見てみましょう。

16
00:00:55,400 --> 00:00:57,960
OrderedCollection は
動的なコレクションで

17
00:00:58,120 --> 00:01:02,160
要素を追加するごとに大きくなっていきます。

18
00:01:02,320 --> 00:01:05,560
Array は固定長のコレクションです。

19
00:01:05,720 --> 00:01:09,200
インデックスを使って要素にアクセスできます。

20
00:01:09,360 --> 00:01:13,280
Set は要素を重複なく格納します。

21
00:01:13,440 --> 00:01:16,200
同じ要素を2度追加することはできません。

22
00:01:16,360 --> 00:01:21,160
Dictionary はハッシュテーブルです。
1つのキーに対して1つの値が関連付けられています。

23
00:01:22,040 --> 00:01:24,840
これはコレクションの階層からの抜粋です。

24
00:01:25,000 --> 00:01:28,160
抜粋にすぎません。
Pharo にあるものはもっと大きいです。

25
00:01:28,320 --> 00:01:31,240
沢山のクラスがあります。
どのコレクションも全コレクション共通の

26
00:01:31,400 --> 00:01:34,120
API を持っています。

27
00:01:34,880 --> 00:01:39,160
このコースでは
それらの API を太字で示します。

28
00:01:40,480 --> 00:01:44,240
7つの共通 API があります。

29
00:01:44,400 --> 00:01:49,240
クラスに送られる
コレクション(creation)生成メソッド

30
00:01:49,400 --> 00:01:52,120
コレクションの特性にアクセスする
(accessing)メソッド

31
00:01:52,280 --> 00:01:54,840
（コレクションのサイズや

32
00:01:55,000 --> 00:01:57,840
格納されている要素など）

33
00:01:58,000 --> 00:02:00,920
コレクションを検査する(testing)メソッド
（コレクションは空か？）

34
00:02:01,080 --> 00:02:05,320
要素を追加(adding)したり取り除く(removing)
メソッドや列挙する(enumerating)メソッド

35
00:02:05,480 --> 00:02:11,400
（要素の一覧を見たり
ある要素が格納されているかを見たり）

36
00:02:11,560 --> 00:02:15,920
そしてコレクションを別の種類のものへ
変換する(converting)メソッド

37
00:02:16,760 --> 00:02:20,640
例題から始めて見ましょう。
Pharo でコレクションを作りたいとします。

38
00:02:20,800 --> 00:02:24,120
単に、興味のあるクラスを選んで

39
00:02:24,280 --> 00:02:28,040
new メッセージを送ることで
そのクラスのインスタンスを生成します。

40
00:02:28,200 --> 00:02:30,360
1つめの選択肢では new を使います。

41
00:02:30,520 --> 00:02:33,720
2つめの選択肢では、直接 new は使いません。

42
00:02:33,880 --> 00:02:36,360
コレクションの大きさを指定したいとします。

43
00:02:36,520 --> 00:02:41,440
new: 4 を送ることができます。
大きさが 4 や 2 の配列を作ります。

44
00:02:41,600 --> 00:02:45,720
このやり方は OrderedCollection でも使えます。
大きさ 1000 のものを作ることができます。

45
00:02:47,400 --> 00:02:51,920
初期化済みのコレクションを作るメソッドもあります。

46
00:02:52,080 --> 00:02:53,520
例えば withAll: です。

47
00:02:53,680 --> 00:02:58,360
リテラルのコレクションを渡します。
リテラルのコレクションは #( で始まります。

48
00:02:59,120 --> 00:03:02,480
要素を渡して、それが全て格納されているような

49
00:03:02,640 --> 00:03:06,760
OrderedCollection の新しいインスタンスを作ります。

50
00:03:07,600 --> 00:03:09,360
Set でも同じことができます。

51
00:03:09,520 --> 00:03:12,760
Set では重複した要素を持つことはできません。

52
00:03:12,920 --> 00:03:16,640
リテラルのコレクションでは
7 が 2 回現れますが

53
00:03:16,800 --> 00:03:19,000
Set の中では 2 つ持つことはできません。

54
00:03:21,200 --> 00:03:25,680
他にも初期化のために

55
00:03:25,840 --> 00:03:27,920
クラスに送ることができるメッセージが
いくつかあります。

56
00:03:28,080 --> 00:03:31,600
new:withAll: もその例です。

57
00:03:31,760 --> 00:03:33,880
大きさが 5 で

58
00:03:34,040 --> 00:03:37,360
全ての要素が特定のオブジェクトであるような
コレクションが欲しい、ということです。

59
00:03:37,520 --> 00:03:40,000
この場合、文字列 a です。

60
00:03:42,240 --> 00:03:46,400
Pharo では全てのコレクションで
インデックスが 1 から始まることを覚えておいてください。

61
00:03:46,560 --> 00:03:49,480
この 3 要素からなるコレクションに

62
00:03:49,640 --> 00:03:53,440
インデックス 2 の要素を返してもらうと
これが返ってきます。

63
00:03:53,600 --> 00:03:56,000
これは 1、これは 2、これは 3 です。

64
00:03:56,760 --> 00:03:58,960
OrderedCollection でも同じです。

65
00:03:59,120 --> 00:04:02,480
このコレクションを変換して
インデックス 2 を返してもらうと

66
00:04:02,640 --> 00:04:04,560
hates が得られます。

67
00:04:05,840 --> 00:04:09,960
コレクションにはあらゆる種類のオブジェクトを
格納することができます。

68
00:04:10,120 --> 00:04:12,280
その例をお見せしましょう。

69
00:04:12,440 --> 00:04:16,920
このリテラルのコレクションは
文字列 calvin と

70
00:04:17,080 --> 00:04:22,000
数 1 と 2 と 3 を格納したコレクション
を格納しています。

71
00:04:22,160 --> 00:04:23,960
配列を作ることができます。

72
00:04:24,120 --> 00:04:28,360
この配列は要素 1 2 と、そして

73
00:04:29,360 --> 00:04:32,600
集合 (Set) から成っています。

74
00:04:33,360 --> 00:04:37,160
要素 1 をここで
そして要素 2、そして集合を追加しました。

75
00:04:37,920 --> 00:04:41,160
例えば do: メッセージを使って

76
00:04:41,320 --> 00:04:43,800
コレクションの要素の一覧を見ることができます。

77
00:04:44,600 --> 00:04:46,400
このコレクションに

78
00:04:47,400 --> 00:04:51,080
do: メッセージを送って
ブロックを渡します。

79
00:04:51,720 --> 00:04:56,920
ブロックは [ で始まって
] で終わります。

80
00:04:57,080 --> 00:05:00,720
ブロックの引数は :each です。

81
00:05:00,880 --> 00:05:03,240
引数はブロックの本体から
| で区切られています。

82
00:05:03,400 --> 00:05:07,200
ループの各回で、each の値は
ブロックの要素を 1 つ目

83
00:05:07,360 --> 00:05:08,800
そして 2 つ目、等となっていきます。

84
00:05:08,960 --> 00:05:12,440
そしてトランスクリプトに
Calvin hates Suzie と表示されます。

85
00:05:14,480 --> 00:05:18,120
配列は固定長のコレクションです。

86
00:05:18,280 --> 00:05:22,280
配列に size メッセージを送ることで
大きさを問い合わせることができます。

87
00:05:22,440 --> 00:05:26,440
at: メッセージを送ることで
配列の要素に直接アクセスできます。

88
00:05:26,600 --> 00:05:28,120
2 つ目の要素が欲しいと。

89
00:05:28,280 --> 00:05:31,640
コレクションの要素を変更することができます

90
00:05:31,800 --> 00:05:35,160
at: 1 put: 'Calvin' を送ることで

91
00:05:35,680 --> 00:05:38,400
1番目のセルに文字列 Calvin を入れます。

92
00:05:39,160 --> 00:05:41,040
大きさを尋ねることもできます。

93
00:05:41,200 --> 00:05:44,600
この例で興味深いことは

94
00:05:44,760 --> 00:05:47,800
同じ配列が 2 通りの方法で
作られていることです。

95
00:05:47,960 --> 00:05:51,720
最初のはリテラルのバージョンで
そして動的なバージョンです。

96
00:05:51,880 --> 00:05:56,360
ここで、自分でArray クラスから
インスタンスを生成して

97
00:05:56,520 --> 00:05:58,120
全てのセルを埋めます。

98
00:05:59,440 --> 00:06:03,200
コレクションに size を送ることで
その大きさを知ることができます。

99
00:06:03,360 --> 00:06:07,600
コレクションの要素に at: メソッドを使って
アクセスすることができます。

100
00:06:07,760 --> 00:06:09,200
これはもう言いましたね。

101
00:06:10,480 --> 00:06:12,480
注意してください。

102
00:06:12,640 --> 00:06:16,000
インデックスを示して
要素にアクセスする時には

103
00:06:16,160 --> 00:06:18,400
必ずインデックスがコレクションの境界内に
あることを確認しなければなりません。

104
00:06:18,560 --> 00:06:23,400
インデックスはコレクションの大きさよりも
小さくなければなりません。

105
00:06:23,560 --> 00:06:27,720
もしコレクションに、
存在しないインデックス 55 の要素を


106
00:06:27,880 --> 00:06:30,400
返すように言ったら
エラーが返ってきます。

107
00:06:33,360 --> 00:06:35,480
このコレクションのインデックス 2 に

108
00:06:35,640 --> 00:06:40,120
新しい要素を入れたいとします。

109
00:06:40,280 --> 00:06:43,960
文字列 love が
文字列 hates の代わりに入ります。

110
00:06:44,120 --> 00:06:46,200
結果を見ればおわかりでしょう。

111
00:06:48,800 --> 00:06:52,080
リテラルの配列です。

112
00:06:52,240 --> 00:06:55,400
これはリテラルの配列の例です。

113
00:06:55,560 --> 00:06:57,840
前に言った通り、#( で始まります。

114
00:06:58,000 --> 00:07:01,520
中にはなんでも入ります。
数や文字列などなど

115
00:07:02,360 --> 00:07:05,160
Pharo ではリテラルの配列は

116
00:07:05,320 --> 00:07:07,840
デフォルトで Array クラスのインスタンスです。

117
00:07:08,000 --> 00:07:10,960
リテラル配列に class メッセージを送ると

118
00:07:11,120 --> 00:07:14,920
Array が返ってきます。
Array クラスのインスタンスということです。

119
00:07:18,800 --> 00:07:22,400
動的な配列とリテラル配列は
Pharo では同じものです。

120
00:07:22,560 --> 00:07:26,440
リテラル配列は単純に短くかけます。
より速く書くことができます。

121
00:07:26,600 --> 00:07:29,760
ここにはリテラルの配列があります。

122
00:07:29,920 --> 00:07:33,760
そして Array クラスのインスタンスを生成した
動的なバージョンがあります。

123
00:07:33,920 --> 00:07:37,240
それらは同じ結果が得られるので
等しいものです。

124
00:07:40,000 --> 00:07:43,560
OrderedCollectionクラスは
拡大することができる

125
00:07:43,720 --> 00:07:45,600
コレクションを定義します。

126
00:07:45,760 --> 00:07:48,640
要素を追加すると、大きくなります。

127
00:07:49,280 --> 00:07:53,320
new メッセージを送ることで
OrderedCollection を生成します。

128
00:07:53,480 --> 00:07:57,040
add: メソッドを使って
このコレクションに新しい要素を加えます。

129
00:07:57,200 --> 00:08:01,280
addFirst: を使ってコレクションの
先頭に要素を追加することもできます。

130
00:08:01,440 --> 00:08:03,080
デフォルトでは末尾に追加されます。

131
00:08:04,400 --> 00:08:07,600
コレクションが何を返すかを見てください。

132
00:08:07,760 --> 00:08:11,440
3つの要素から成っています。
Pharo、 Reef、そして Pharo です。

133
00:08:11,600 --> 00:08:15,400
add: 'Seaside'で
末尾に 'Seaside' が追加されます。

134
00:08:17,760 --> 00:08:21,520
変換 (conversion) メソッドで
異なる種類のコレクションに変換することができます。

135
00:08:21,680 --> 00:08:26,160
ここでリテラルのコレクションがあります。
配列です。

136
00:08:26,320 --> 00:08:30,440
asOrderedCollection メッセージは
この配列を

137
00:08:30,600 --> 00:08:32,600
OrderedCollection に変換します。

138
00:08:33,520 --> 00:08:37,200
Set は重複のないコレクションです。

139
00:08:37,360 --> 00:08:41,600
Set は拡大することができます。
要素を追加するたびに大きくなります。

140
00:08:41,760 --> 00:08:45,560
リテラルのコレクションを使って
そこから Set に変換できます。

141
00:08:45,720 --> 00:08:49,080
重複のない Set が最終的に得られます。

142
00:08:49,880 --> 00:08:53,400
リテラルではなく動的なやり方を
選択することもできます。

143
00:08:53,560 --> 00:08:57,720
Set with: with: は集合を作って
2つの要素を入れます。

144
00:08:57,880 --> 00:08:59,440
それぞれの要素が集合になっています。

145
00:09:02,000 --> 00:09:06,640
変換メソッドは、ある種類のコレクションを
別の種類に変換するのに便利です。

146
00:09:06,800 --> 00:09:11,280
as に欲しいコレクションの名前を付けたものです。

147
00:09:13,840 --> 00:09:17,000
Dictionaryはキーと値のコレクションです。

148
00:09:17,160 --> 00:09:19,280
キーと値を関連付けます。

149
00:09:19,440 --> 00:09:22,760
Dictionary は拡大することができます。
要素を追加するごとに大きくなります。

150
00:09:22,920 --> 00:09:25,560
Dictionaryについては

151
00:09:25,720 --> 00:09:28,360
他のコレクションにないような
API があります。

152
00:09:28,520 --> 00:09:32,120
よくある at: メッセージに加えて
at:ifAbsent: メッセージ

153
00:09:32,280 --> 00:09:37,200
(アクセスしたいキーが存在していなかった時に
どうするか？です）

154
00:09:37,360 --> 00:09:42,160
at:put: はキーに新しい値を入れます。

155
00:09:42,320 --> 00:09:47,520
列挙する時によく使う do: メッセージも
使うことができますが

156
00:09:47,680 --> 00:09:49,080
他のメッセージも使えます。

157
00:09:49,240 --> 00:09:52,640
keysDo: はその辞書の全てのキーを一覧します。

158
00:09:52,800 --> 00:09:54,280
keys や values もあります。

159
00:09:54,440 --> 00:09:58,240
例えば、Dictuionary クラスの
インスタンスを生成します。

160
00:09:59,040 --> 00:10:03,360
辞書を配列のように思い描いてみてください。

161
00:10:03,520 --> 00:10:08,040
January をキーとして、31 を関連付けて
Februaryをキーとして28

162
00:10:08,200 --> 00:10:10,160
Marchをキーとして31と。

163
00:10:12,840 --> 00:10:16,280
これは動的なコレクションと等価です。

164
00:10:16,440 --> 00:10:21,480
{ と } を使って動的なコレクションを

165
00:10:21,640 --> 00:10:23,720
作ることができます。

166
00:10:23,880 --> 00:10:26,640
関連を作るためには
矢印を使います。

167
00:10:26,800 --> 00:10:29,000
これはシンボルです。

168
00:10:29,160 --> 00:10:33,080
シンボル January に数 31 を関連付けます。

169
00:10:33,240 --> 00:10:35,720
関連のコレクションがあります。

170
00:10:35,880 --> 00:10:38,440
これを asDictionary で
Dictionaryに変換します。

171
00:10:38,600 --> 00:10:42,840
辞書を生成するこれら2つの方法は等価です。

172
00:10:45,480 --> 00:10:48,280
関連付けにキーを問い合わせれば

173
00:10:48,440 --> 00:10:50,760
そのキーが返ってきます。
最初のほうです。

174
00:10:50,920 --> 00:10:52,400
同じです。

175
00:10:52,560 --> 00:10:56,400
関連付けに値を問い合わせれば
その値を返します。

176
00:10:56,560 --> 00:10:58,760
これがペアであり関連付けです。

177
00:11:00,560 --> 00:11:01,760
辞書について。

178
00:11:01,920 --> 00:11:06,080
辞書の特定の値にアクセスしたい場合には

179
00:11:06,240 --> 00:11:11,600
at: を使って、値を知りたいキーを指定します。

180
00:11:11,760 --> 00:11:13,800
もしキーが存在しなければ

181
00:11:14,360 --> 00:11:17,720
代わりにエラーが得られます。

182
00:11:18,560 --> 00:11:23,000
それを避けるためには
at:ifAbsent: を使うことができます。

183
00:11:23,160 --> 00:11:26,600
at: に続いて辞書中にないキーを書きます。

184
00:11:26,760 --> 00:11:30,720
なければ、この値、0 を返します。

185
00:11:31,480 --> 00:11:35,040
このキーはこの辞書に入っていないので
0 が返ってきます。

186
00:11:35,200 --> 00:11:40,480
辞書の中を列挙することができます。
do: を使うと

187
00:11:40,640 --> 00:11:45,280
辞書の値のみを得ることになります。
キーは得られません。

188
00:11:45,440 --> 00:11:48,800
なぜか疑問に思うかもしれません。
とても奇妙です。

189
00:11:48,960 --> 00:11:50,720
しかし実際にはとても合理的です。

190
00:11:50,880 --> 00:11:55,560
もし Dictionary での do: の実装を見れば

191
00:11:55,720 --> 00:11:58,760
何があるかというと
^ self valuesDo: です。

192
00:11:58,920 --> 00:12:01,480
デフォルトでは、辞書に do: を適用すると

193
00:12:01,640 --> 00:12:04,080
キーではなく値だけを一覧します。

194
00:12:05,440 --> 00:12:07,040
もし両方とも一覧したければ

195
00:12:07,200 --> 00:12:10,680
それ用のメソッド keysAndValuesDo: を
使わなければなりません。

196
00:12:10,840 --> 00:12:15,120
keysAndValuesDo: は :k と :y の
2 つの引数をとるブロックを取ります。

197
00:12:15,280 --> 00:12:18,680
:k はキーで v: は値です。

198
00:12:19,360 --> 00:12:22,160
この辞書には中身が詰まっています。

199
00:12:23,880 --> 00:12:26,720
このコースでは

200
00:12:26,880 --> 00:12:30,520
Pharo には沢山の種類のコレクションが
利用できることを学びました。

201
00:12:31,160 --> 00:12:33,800
コレクションには共通の語彙があります。

202
00:12:33,960 --> 00:12:35,720
生成すること

203
00:12:35,880 --> 00:12:38,760
要素にアクセスすること
サイズなど

204
00:12:38,920 --> 00:12:41,080
プログラマーを楽にしてくれます。

205
00:12:41,240 --> 00:12:44,560
コレクションを他の種類に
簡単に変換することができます。

206
00:12:44,720 --> 00:12:46,600
他にも、もっと学びました。

207
00:12:46,760 --> 00:12:50,800
何かわからないことがあったら
システムの中を見ることはとても簡単です。


208
00:12:50,960 --> 00:12:54,960
Pharo の中身、クラスのコードを読んで
コレクションの他のクラスを学ぶことができます。
