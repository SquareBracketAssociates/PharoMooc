WEBVTT

00:00:00.440 --> 00:00:02.600 align:middle
こんにちは。
前回のセッションでは

00:00:02.760 --> 00:00:06.880 align:middle
真偽値の not と or の
実装方法をみてきました。

00:00:07.040 --> 00:00:11.960 align:middle
3つ目の問題が残っています。
一体なぜこれらの問題をやるのか？

00:00:12.120 --> 00:00:13.880 align:middle
それを学びます。

00:00:14.760 --> 00:00:20.120 align:middle
実装を振り返ってみましょう。
not について。2つのオブジェクトがありました。

00:00:20.280 --> 00:00:22.400 align:middle
true と false です。

00:00:22.560 --> 00:00:25.440 align:middle
True クラスと False クラスのインスタンスでした。

00:00:25.600 --> 00:00:27.200 align:middle
not メッセージを送ると

00:00:27.360 --> 00:00:31.640 align:middle
それぞれに対応するクラスに問い合わせて
メソッドを実行しました。

00:00:32.560 --> 00:00:34.080 align:middle
問題ないですね。

00:00:35.120 --> 00:00:37.240 align:middle
伝えたことは

00:00:37.400 --> 00:00:39.720 align:middle
何かと言うと

00:00:39.880 --> 00:00:42.920 align:middle
まず第一に、レシーバーに決めさせること。

00:00:43.080 --> 00:00:46.080 align:middle
つまり、自分では何も決めないで

00:00:46.240 --> 00:00:49.320 align:middle
メッセージを送ることで解決します。

00:00:49.480 --> 00:00:53.840 align:middle
経験則が2つありました。
レシーバーに決めさせること。

00:00:54.000 --> 00:00:57.320 align:middle
そして、「求めるな、命じよ」です。

00:00:57.480 --> 00:00:58.960 align:middle
これについては、後でまた出てきます。

00:00:59.120 --> 00:01:02.480 align:middle
では、練習問題自体を見てみましょう。

00:01:03.080 --> 00:01:04.720 align:middle
さて、これは何なのでしょう？

00:01:04.880 --> 00:01:08.240 align:middle
あなたが今後人生において
真偽値を実装することは決してないでしょう。

00:01:08.400 --> 00:01:10.080 align:middle
少なくとも、私はそう願います。

00:01:10.240 --> 00:01:13.000 align:middle
では全く使い道がないことでしょうか？

00:01:13.160 --> 00:01:15.920 align:middle
背後にある教えは、何でしょうか？

00:01:16.080 --> 00:01:19.240 align:middle
私はこの問題を問うことは
とても重要なことだと考えています。

00:01:19.400 --> 00:01:23.600 align:middle
実装はあんな感じだとして
だからどうだというのでしょう？

00:01:24.560 --> 00:01:29.360 align:middle
メッセージ送信をする時にはいつも

00:01:29.520 --> 00:01:33.640 align:middle
case 文を実行しているということです。

00:01:35.000 --> 00:01:38.800 align:middle
C プログラミング等によくあることです。

00:01:39.880 --> 00:01:42.840 align:middle
メッセージを送ることは
複数の選択肢から選ぶということです。

00:01:44.160 --> 00:01:46.880 align:middle
興味深いことは
メッセージを送ると

00:01:47.040 --> 00:01:50.720 align:middle
単なる case 文ではないということです。
動的な case 文になっています。

00:01:50.880 --> 00:01:54.960 align:middle
実際、メッセージ送信はロードされている
クラスや生成されたインスタンスに依存します。

00:01:55.720 --> 00:01:58.640 align:middle
Java でプログラムを書く時にはよく

00:01:58.800 --> 00:02:02.040 align:middle
x.f() を書くことで

00:02:02.200 --> 00:02:04.080 align:middle
メソッド f を実行します。

00:02:04.240 --> 00:02:07.240 align:middle
ここで説明していることは、つまり
このピリオド（.）は

00:02:08.000 --> 00:02:09.560 align:middle
選択をおこなう演算子だということです。

00:02:10.840 --> 00:02:12.600 align:middle
とても大事なことは

00:02:13.400 --> 00:02:15.360 align:middle
この選択は動的だということです。

00:02:15.520 --> 00:02:17.800 align:middle
これまであまり言ってきませんでしたが

00:02:17.960 --> 00:02:22.960 align:middle
これこそが、例をもって示したかったことなのです。

00:02:23.120 --> 00:02:25.840 align:middle
まとめると
メッセージを送ることは

00:02:26.000 --> 00:02:29.360 align:middle
動的な case 文のような機能を果たします。

00:02:29.520 --> 00:02:33.120 align:middle
動的というのは
ロードされているクラスに依存するという意味です。

00:02:33.280 --> 00:02:36.440 align:middle
この真偽値の例題では
2つのインスタンスと2つのクラスを扱いました。

00:02:36.600 --> 00:02:39.600 align:middle
たとえ50個だったとしても
同じように動きます。

00:02:40.320 --> 00:02:43.920 align:middle
バーチャルマシンにメッセージを送ることで

00:02:44.080 --> 00:02:47.400 align:middle
（Pharo は Java や C# のように
　バーチャルマシンを使います）

50 align:middle
00:02:47,560 --> 00:02:50,520
バーチャルマシンの実行装置が

00:02:50.680 --> 00:02:54.400 align:middle
レシーバーのクラスに応じて
正しいメソッドを選択します。

00:02:54.560 --> 00:02:58.160 align:middle
したがって、メッセージ送信は
選択演算子なのです。

00:02:58.320 --> 00:03:00.520 align:middle
条件分岐を使うたびに

00:03:00.680 --> 00:03:04.360 align:middle
それを

00:03:04.520 --> 00:03:07.920 align:middle
バーチャルマシンによる選択に
置き換えることができます。

00:03:08.800 --> 00:03:11.400 align:middle
つまり、not についての解答は

00:03:11.560 --> 00:03:13.560 align:middle
プログラムを実装する時には

00:03:13.720 --> 00:03:17.240 align:middle
バーチャルマシンによる選択を
使うべきだということです。

00:03:17.400 --> 00:03:19.720 align:middle
if 文を使う必要はありません。

00:03:19.880 --> 00:03:24.240 align:middle
なぜなら、メッセージを送ることが
if や条件分岐と同じ意味になるのです。

00:03:24.400 --> 00:03:26.920 align:middle
ここで疑問に思うかもしれません。

00:03:27.080 --> 00:03:31.160 align:middle
最初の練習問題を全く別の方法で実装していたら
どうなのだろうか？と。

00:03:31.320 --> 00:03:35.160 align:middle
もし練習問題が「Boolean クラスに

00:03:35.320 --> 00:03:37.000 align:middle
not や or を実装しなさい」だったら
どうでしょう？

00:03:37.160 --> 00:03:39.400 align:middle
今回の解答のやり方では
うまくいかないでしょう。

00:03:40.200 --> 00:03:42.720 align:middle
おかしいですね。
どういうことでしょうか？

00:03:42.880 --> 00:03:45.680 align:middle
クラスが1つあるか複数あるかは
アプリケーションの設計に

00:03:45.840 --> 00:03:48.400 align:middle
とても大きな影響を与えます。

00:03:49.120 --> 00:03:50.120 align:middle
まったくもって

00:03:51.440 --> 00:03:56.560 align:middle
クラスは分岐や選択の役割を
担っているのです。

00:03:56.720 --> 00:03:59.080 align:middle
ヨーグルトを選ぼうとしているとして

00:03:59.240 --> 00:04:03.200 align:middle
店にヨーグルトのポットが1つしかなければ
そのヨーグルトを選ぶしかないのです。

00:04:03.360 --> 00:04:04.400 align:middle
そういうことなのです。

00:04:04.560 --> 00:04:06.520 align:middle
つまり、クラスは

00:04:07.520 --> 00:04:09.440 align:middle
継承木の中での1つの case を表しています。

00:04:09.600 --> 00:04:10.880 align:middle
それが意味することは

00:04:11.040 --> 00:04:14.040 align:middle
1つの大きく太ったクラスに
メソッドが沢山あるような

00:04:14.200 --> 00:04:17.160 align:middle
そんなデザインがあれば

00:04:17.320 --> 00:04:20.920 align:middle
それと同じことを階層を使って表現できる
ということです。

00:04:21.080 --> 00:04:25.280 align:middle
そのほうが良い設計です。
よりモジュール化されています。

00:04:25.440 --> 00:04:29.680 align:middle
必要ならば別の選択肢を加えることも
簡単にできます。

00:04:29.840 --> 00:04:32.760 align:middle
「これは悪くないが

00:04:32.920 --> 00:04:35.960 align:middle
新しい選択肢を持てるように改良できるね」
と言って拡張するのです。

00:04:36.120 --> 00:04:38.880 align:middle
さらに複雑度を減らすことができます。

00:04:39.040 --> 00:04:43.840 align:middle
1つのクラスに集中することができます。
あまりにも多くの条件を抱えたものではなく。

00:04:44.800 --> 00:04:49.000 align:middle
片方の手には選択演算子があり

00:04:49.160 --> 00:04:52.640 align:middle
もう一方の手には選択肢を表したものを持っています。

00:04:52.800 --> 00:04:57.640 align:middle
それらをくっつけると
良い品質の OOP になります。

00:04:57.800 --> 00:05:00.040 align:middle
さらに良いことに

00:05:00.200 --> 00:05:03.520 align:middle
階層による解決を使うと

00:05:03.680 --> 00:05:07.120 align:middle
それをパッケージ化することができます。

00:05:07.280 --> 00:05:11.480 align:middle
つまり、ある部分はコアとしてパッケージして
別の部分をプラグインとしてパッケージできます。

00:05:11.640 --> 00:05:14.640 align:middle
そして顧客に言うのです。
「この機能が必要であれば

00:05:14.800 --> 00:05:17.720 align:middle
この有償プラグインをダウンロードしてください」

00:05:17.880 --> 00:05:20.360 align:middle
そしてそのコードを動的にロードします。

00:05:20.520 --> 00:05:23.760 align:middle
このクラスのインスタンスを生成すると

00:05:25.400 --> 00:05:27.840 align:middle
オペレーションメッセージを送れば

00:05:28.520 --> 00:05:31.840 align:middle
プラグインのコードがシステムの中で
実行されます。

00:05:32.000 --> 00:05:36.440 align:middle
それが OOP のエッセンスです。

00:05:36.600 --> 00:05:40.120 align:middle
メッセージを送ると
正しいメソッドが選択される

00:05:40.960 --> 00:05:45.040 align:middle
そしてシステムが正しいメソッドを
選択することを知っていることで

00:05:45.200 --> 00:05:47.960 align:middle
よりエレガントな実装をすることができます。

00:05:48.120 --> 00:05:50.320 align:middle
何を学んだのでしょうか？

00:05:50.480 --> 00:05:55.040 align:middle
学んだことは、メッセージを送ることで
レシーバーに選択させて何かを決めさせることです。

00:05:55.200 --> 00:05:58.400 align:middle
クライアントは何も決める必要ありません。

00:05:58.560 --> 00:06:00.760 align:middle
クライアントコードは宣言的です。

00:06:00.920 --> 00:06:04.800 align:middle
条件分岐はありません。命令を与えるのです。
「これをやれ」「あれをやれ」「開け」「閉じろ」と。

00:06:04.960 --> 00:06:09.280 align:middle
「このクラスに属していますか？」や
「閉じられていますか？」ではなく。

00:06:09.440 --> 00:06:12.520 align:middle
違いはレシーバーが動的に置き換えられる
可能性があることです。

00:06:12.680 --> 00:06:15.840 align:middle
このことは後でまた出てきます。
ただし直接ではありません。暗黙に。

00:06:16.560 --> 00:06:20.240 align:middle
そういうことで、多くの場合
if 文を書くことを避けるようにしてください。

00:06:21.240 --> 00:06:23.560 align:middle
できるだけオブジェクトとメッセージを使うように。

00:06:23.720 --> 00:06:27.760 align:middle
いつもそうだというわけではないですが
少なくともできるだけ使うようにしてください。

00:06:29.280 --> 00:06:31.880 align:middle
実行エンジン
バーチャルマシンは

00:06:32.040 --> 00:06:37.120 align:middle
メッセージを送るたびに
条件スイッチとして動作します。

00:06:37.680 --> 00:06:39.000 align:middle
それを使うことです。

00:06:39.160 --> 00:06:41.960 align:middle
キーボードを打つ時はいつも
アンチ if キャンペーンを楽しんでください。

00:06:42.120 --> 00:06:46.800 align:middle
if 文を書くのをやめさせるために
プログラマー達がこのキャンペーンを立ち上げました。

00:06:48.760 --> 00:06:50.960 align:middle
さて、このセッションでは何を学んだでしょうか？

00:06:51.120 --> 00:06:53.280 align:middle
2つのことがありました。
Java や Pharo で

00:06:53.440 --> 00:06:57.720 align:middle
x.f() と書いたら

00:06:58.600 --> 00:07:02.400 align:middle
選択肢を作ることになります。

00:07:02.560 --> 00:07:06.080 align:middle
レシーバーに応じて実行されるべき
メソッド f が選択されます。

00:07:06.840 --> 00:07:08.640 align:middle
つまり選択演算子ということです。

00:07:08.800 --> 00:07:12.000 align:middle
そして階層が可能な選択肢を表現します。

00:07:12.160 --> 00:07:16.560 align:middle
つまりどんな選択が可能かを決める
枠組みだということです。

00:07:16.720 --> 00:07:20.800 align:middle
結果として条件分岐のない
拡張性のあるプログラムを書くことができます。

00:07:21.800 --> 00:07:24.480 align:middle
これで Pharo でのオブジェクト設計についての

00:07:24.640 --> 00:07:27.160 align:middle
最初のセッションを終わります。

00:07:28.160 --> 00:07:30.520 align:middle
次のセッションでもオブジェクト設計について
さらに見ていきます。

