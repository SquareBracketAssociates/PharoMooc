1
00:00:00,560 --> 00:00:04,680
今日は前にやった内容の
復習をしますが

2
00:00:04,840 --> 00:00:07,120
じっくりやってください。

3
00:00:07,280 --> 00:00:09,920
文字、文字列、シンボルです。

4
00:00:10,920 --> 00:00:14,560
今日学ぶことは
文字の扱い方や

5
00:00:14,720 --> 00:00:16,360
文字列の表現や

6
00:00:16,520 --> 00:00:19,160
文字列とシンボルの関係についてです。

7
00:00:19,520 --> 00:00:21,960
では始めましょう。
文字です。

8
00:00:22,120 --> 00:00:25,920
Pharo では文字は
ドルマークで始まり

9
00:00:26,200 --> 00:00:28,600
それに文字が続きます。

10
00:00:28,880 --> 00:00:32,680
こうやって文字のリテラルを表現します。

11
00:00:33,200 --> 00:00:36,960
非表示文字は

12
00:00:37,120 --> 00:00:40,720
空白やタブや

13
00:00:40,880 --> 00:00:42,920
改行などがありますが

14
00:00:43,080 --> 00:00:46,200
Character クラスに
メッセージを送ることで

15
00:00:46,360 --> 00:00:47,920
こういった文字を得ることができます。

16
00:00:49,960 --> 00:00:51,160
では文字列です。

17
00:00:51,320 --> 00:00:54,720
文字列は引用符（'）で囲まれています。

18
00:00:54,880 --> 00:00:56,880
この文字です。

19
00:00:57,040 --> 00:01:00,320
ここに文字列「eclair au chocolat」
があります。

20
00:01:00,480 --> 00:01:02,440
ここから始まって、ここで終わります。

21
00:01:02,680 --> 00:01:05,520
文字列にメッセージを送ることができます。
例えば、size です。

22
00:01:05,680 --> 00:01:08,400
すると 18 が返ってきます。

23
00:01:08,560 --> 00:01:11,760
実際、この文字列は
18 文字から成っています。

24
00:01:12,240 --> 00:01:14,320
もっと色々と文字列を操ることができます。

25
00:01:14,480 --> 00:01:16,880
例えば、 Character space split:
とすると

26
00:01:17,120 --> 00:01:21,440
引数の文字列が空白で切り分けられて

27
00:01:21,600 --> 00:01:25,040
3 つの要素からなる OrderedCollection
（順序つきコレクション）が得られます。

28
00:01:25,200 --> 00:01:28,160
文字列が 3 つに切り分けられるわけです。

29
00:01:28,960 --> 00:01:34,000
Pharo では、文字列はコレクションです。

30
00:01:34,160 --> 00:01:37,440
本当に文字の列になっています。

31
00:01:37,600 --> 00:01:41,120
String クラスは Collection クラスから
継承しているので

32
00:01:41,560 --> 00:01:44,360
Collectionのメソッドを
使うことができます。

33
00:01:44,520 --> 00:01:49,120
よく使われるコレクションクラスがあります。

34
00:01:49,280 --> 00:01:52,960
例えば IndexedCollection では
at: があります。

35
00:01:53,120 --> 00:01:55,240
'eclair au chocolat' at: 1

36
00:01:55,400 --> 00:01:59,160
とすると、このコレクションの
1 番目の要素として「e」が得られます。

37
00:01:59,520 --> 00:02:01,480
この「e」です。

38
00:02:02,480 --> 00:02:06,560
do: を使って要素を
走査することもできます。

39
00:02:06,720 --> 00:02:09,320
ループの中でブロックが

40
00:02:09,480 --> 00:02:13,960
コレクションの 1 文字目、2 文字目
とセットしていきます。

41
00:02:14,120 --> 00:02:15,640
1 つ、細かなことですが

42
00:02:15,800 --> 00:02:19,720
文字列は引用符（'）で区切られるのですが

43
00:02:19,880 --> 00:02:22,200
文字列中に引用符を入れたい時には

44
00:02:22,360 --> 00:02:24,960
引用符（'）を 2 つ連続して入れてください。

45
00:02:25,120 --> 00:02:29,960
こうすることで、文字列中に
1 つの引用符（'）を入れることができます。

46
00:02:30,120 --> 00:02:32,440
ただし、文字列の中で

47
00:02:32,600 --> 00:02:35,640
その引用符は 1 文字として扱われます。

48
00:02:35,800 --> 00:02:39,720
例えば
'L''eclair au chocolat' at: 2

49
00:02:39,880 --> 00:02:42,560
とすると、このコレクションの
2 番目の要素として

50
00:02:42,720 --> 00:02:45,040
引用符「'」が返ってきます。

51
00:02:45,200 --> 00:02:49,160
そして at: 3 とすると
ここにある「e」が得られます。

52
00:02:49,320 --> 00:02:54,640
引用符を 2 つ書き込んでも
それは  1 文字として扱われます。

53
00:02:56,800 --> 00:03:01,240
文字列は他のコレクションと同じように
扱うことができます。

54
00:03:01,400 --> 00:03:05,440
文字列の最後の要素を得るためには

55
00:03:05,600 --> 00:03:10,320
str at: str size
とすることができます。

56
00:03:10,480 --> 00:03:13,960
忘れてはいけないのは、Pharo では
インデックスが 1 から始まることです。

57
00:03:14,120 --> 00:03:17,400
したがって、文字列のサイズが
最後の文字のインデックスになります。

58
00:03:17,640 --> 00:03:22,320
あるいは、単に last を送ることで
最後の要素を得ることができます。

59
00:03:22,840 --> 00:03:26,200
文字列を生成するためには
いろいろなやり方があります。

60
00:03:26,360 --> 00:03:29,760
簡単なのは変換メソッドを使うことです。

61
00:03:29,920 --> 00:03:33,560
シンボルを文字列に変換するには
asString メッセージを使います。

62
00:03:33,720 --> 00:03:36,960
あるいは、どんなオブジェクトに対しても
printString を送ることができます。

63
00:03:37,120 --> 00:03:41,200
すると、そのオブジェクトの
文字列表現が得られます。

64
00:03:42,400 --> 00:03:46,240
あるいは、コレクション生成メソッドを
直接使ううことで文字列を生成できます。

65
00:03:46,400 --> 00:03:49,840
任意のコレクションクラスに
with: を送ることで

66
00:03:50,000 --> 00:03:54,640
引数として渡した要素を含むコレクションを
生成することができます。覚えていますよね。

67
00:03:54,800 --> 00:03:56,600
String with: $A
とすると

68
00:03:56,760 --> 00:04:00,520
1 文字「A」からなる文字列が得られます。

69
00:04:00,680 --> 00:04:02,120
文字列を連結するためには

70
00:04:02,280 --> 00:04:05,640
もう見たと思いますが、コンマを使います。

71
00:04:05,800 --> 00:04:09,640
「,」を文字列に送って
引数として文字列を渡すと

72
00:04:09,800 --> 00:04:13,800
それら 2 つの文字列を連結した
新しい文字列を生成します。

73
00:04:14,560 --> 00:04:16,160
ただし、気をつけなければならないのは

74
00:04:16,320 --> 00:04:19,400
この例のようなことをすると

75
00:04:19,560 --> 00:04:23,440
無用な中間生成物をつくってしまう
ということを忘れないでください。

76
00:04:23,600 --> 00:04:27,440
つまり、この文字列に
最初の , メッセージを

77
00:04:27,600 --> 00:04:30,120
この引数で送ると

78
00:04:30,280 --> 00:04:34,600
最初の連結文字列が生成されます。

79
00:04:34,920 --> 00:04:38,800
この連結文字列に , を送ると

80
00:04:38,960 --> 00:04:41,680
また別の連結文字列が生成されて
それが最終的な返り値になります。

81
00:04:41,840 --> 00:04:45,280
中間文字列が生成されてしまい

82
00:04:45,440 --> 00:04:48,680
計算時間の無駄になります。

83
00:04:48,840 --> 00:04:51,560
ベンチマークの講義がありましたね。

84
00:04:51,720 --> 00:04:55,840
何が起こっているのか
ベンチマークで見て

85
00:04:56,000 --> 00:04:59,240
そしてストリームを使うべきか
判断してください。

86
00:04:59,400 --> 00:05:02,000
文字列を生成するために

87
00:05:02,160 --> 00:05:06,000
streamContents: を使って

88
00:05:06,160 --> 00:05:11,320
このストリームに文字を直接送り込んで
最終的な文字列を生成することができます。

89
00:05:11,480 --> 00:05:14,200
この方法を使うと、文字列が中間生成される
のを避けることができます。

90
00:05:14,360 --> 00:05:16,760
さて、シンボルですが

91
00:05:16,920 --> 00:05:21,200
構文的には
シンボルはハッシュタグで始まります。

92
00:05:21,360 --> 00:05:23,120
そして文字列が続きます。

93
00:05:23,280 --> 00:05:24,880
これがシンボルのリテラルです。

94
00:05:25,040 --> 00:05:29,760
これはある種の文字列ですが
システム内でユニークな文字列です。

95
00:05:29,920 --> 00:05:33,200
プログラムのどこかで
ハッシュタグに続いて「ほげほげ」書くと

96
00:05:33,360 --> 00:05:36,320
プログラム中の他の箇所での
ハッシュタグ「ほげほげ」は

97
00:05:36,480 --> 00:05:38,760
同一のオブジェクトを指すことになります。

98
00:05:38,920 --> 00:05:40,680
同じインスタンスを指すということです。

99
00:05:41,400 --> 00:05:43,640
これがシンボルはユニークということです。

100
00:05:43,800 --> 00:05:48,480
ここに #calvin == #calvin とありますが
true になります。

101
00:05:48,640 --> 00:05:50,120
同一オブジェクトということです。

102
00:05:50,280 --> 00:05:53,760
文字列の場合はそうはなりません。
場合によります。

103
00:05:53,920 --> 00:05:57,000
コンパイラの最適化によって
変わってきます。

104
00:05:57,400 --> 00:06:01,440
これがシンボルと文字列の違いです。

105
00:06:01,600 --> 00:06:05,360
シンボルは完全にリードオンリーです。

106
00:06:05,520 --> 00:06:08,600
シンボルは書き換えることができません。
新しいシンボルを生成する必要があります。

107
00:06:08,760 --> 00:06:13,080
シンボルはユニークなオブジェクト
つまり常に同じオブジェクトを指します。

108
00:06:13,240 --> 00:06:17,440
文字列はミュータブルなオブジェクトで
内容を書き換えることができます。

109
00:06:17,600 --> 00:06:22,440
今のところは。実際のところ
現在まだ議論の対象になっています。

110
00:06:24,080 --> 00:06:26,440
シンボルはメソッドセレクターとして

111
00:06:27,560 --> 00:06:30,320
よく使われます。

112
00:06:31,480 --> 00:06:35,160
そしてシンボルは辞書（Dictionary）の

113
00:06:35,320 --> 00:06:37,160
キーとして有用です。

114
00:06:37,320 --> 00:06:39,080
IdentityDictionary を

115
00:06:39,240 --> 00:06:40,560
知っていますか？

116
00:06:40,720 --> 00:06:43,160
辞書のキーとして使うと

117
00:06:43,320 --> 00:06:48,600
比較のためにハッシュを計算して

118
00:06:48,760 --> 00:06:51,200
辞書の中に格納します。

119
00:06:52,680 --> 00:06:56,360
この講義で重要なことは

120
00:06:56,520 --> 00:07:00,120
文字列は他のコレクションと同様であること

121
00:07:00,280 --> 00:07:03,360
そしてシンボルはユニークであり

122
00:07:03,520 --> 00:07:06,320
リードオンリーで
イミュータブルであることです。