WEBVTT

00:00:00.560 --> 00:00:04.680 align:middle
今日は前にやった内容の
復習をしますが

00:00:04.840 --> 00:00:07.120 align:middle
じっくりやってください。

00:00:07.280 --> 00:00:09.920 align:middle
文字、文字列、シンボルです。

00:00:10.920 --> 00:00:14.560 align:middle
今日学ぶことは
文字の扱い方や

00:00:14.720 --> 00:00:16.360 align:middle
文字列の表現や

00:00:16.520 --> 00:00:19.160 align:middle
文字列とシンボルの関係についてです。

00:00:19.520 --> 00:00:21.960 align:middle
では始めましょう。
文字です。

00:00:22.120 --> 00:00:25.920 align:middle
Pharo では文字は
ドルマークで始まり

00:00:26.200 --> 00:00:28.600 align:middle
それに文字が続きます。

00:00:28.880 --> 00:00:32.680 align:middle
こうやって文字のリテラルを表現します。

00:00:33.200 --> 00:00:36.960 align:middle
非表示文字は

00:00:37.120 --> 00:00:40.720 align:middle
空白やタブや

00:00:40.880 --> 00:00:42.920 align:middle
改行などがありますが

00:00:43.080 --> 00:00:46.200 align:middle
Character クラスに
メッセージを送ることで

00:00:46.360 --> 00:00:47.920 align:middle
こういった文字を得ることができます。

00:00:49.960 --> 00:00:51.160 align:middle
では文字列です。

00:00:51.320 --> 00:00:54.720 align:middle
文字列は引用符（'）で囲まれています。

00:00:54.880 --> 00:00:56.880 align:middle
この文字です。

00:00:57.040 --> 00:01:00.320 align:middle
ここに文字列「eclair au chocolat」
があります。

00:01:00.480 --> 00:01:02.440 align:middle
ここから始まって、ここで終わります。

00:01:02.680 --> 00:01:05.520 align:middle
文字列にメッセージを送ることができます。
例えば、size です。

00:01:05.680 --> 00:01:08.400 align:middle
すると 18 が返ってきます。

00:01:08.560 --> 00:01:11.760 align:middle
実際、この文字列は
18 文字から成っています。

00:01:12.240 --> 00:01:14.320 align:middle
もっと色々と文字列を操ることができます。

00:01:14.480 --> 00:01:16.880 align:middle
例えば、 Character space split:
とすると

00:01:17.120 --> 00:01:21.440 align:middle
引数の文字列が空白で切り分けられて

00:01:21.600 --> 00:01:25.040 align:middle
3 つの要素からなる OrderedCollection
（順序つきコレクション）が得られます。

00:01:25.200 --> 00:01:28.160 align:middle
文字列が 3 つに切り分けられるわけです。

00:01:28.960 --> 00:01:34.000 align:middle
Pharo では、文字列はコレクションです。

00:01:34.160 --> 00:01:37.440 align:middle
本当に文字の列になっています。

00:01:37.600 --> 00:01:41.120 align:middle
String クラスは Collection クラスから
継承しているので

00:01:41.560 --> 00:01:44.360 align:middle
Collectionのメソッドを
使うことができます。

00:01:44.520 --> 00:01:49.120 align:middle
よく使われるコレクションクラスがあります。

00:01:49.280 --> 00:01:52.960 align:middle
例えば IndexedCollection では
at: があります。

00:01:53.120 --> 00:01:55.240 align:middle
'eclair au chocolat' at: 1

00:01:55.400 --> 00:01:59.160 align:middle
とすると、このコレクションの
1 番目の要素として「e」が得られます。

00:01:59.520 --> 00:02:01.480 align:middle
この「e」です。

00:02:02.480 --> 00:02:06.560 align:middle
do: を使って要素を
走査することもできます。

00:02:06.720 --> 00:02:09.320 align:middle
ループの中でブロックが

00:02:09.480 --> 00:02:13.960 align:middle
コレクションの 1 文字目、2 文字目
とセットしていきます。

00:02:14.120 --> 00:02:15.640 align:middle
1 つ、細かなことですが

00:02:15.800 --> 00:02:19.720 align:middle
文字列は引用符（'）で区切られるのですが

00:02:19.880 --> 00:02:22.200 align:middle
文字列中に引用符を入れたい時には

00:02:22.360 --> 00:02:24.960 align:middle
引用符（'）を 2 つ連続して入れてください。

00:02:25.120 --> 00:02:29.960 align:middle
こうすることで、文字列中に
1 つの引用符（'）を入れることができます。

00:02:30.120 --> 00:02:32.440 align:middle
ただし、文字列の中で

00:02:32.600 --> 00:02:35.640 align:middle
その引用符は 1 文字として扱われます。

00:02:35.800 --> 00:02:39.720 align:middle
例えば
'L''eclair au chocolat' at: 2

00:02:39.880 --> 00:02:42.560 align:middle
とすると、このコレクションの
2 番目の要素として

00:02:42.720 --> 00:02:45.040 align:middle
引用符「'」が返ってきます。

00:02:45.200 --> 00:02:49.160 align:middle
そして at: 3 とすると
ここにある「e」が得られます。

00:02:49.320 --> 00:02:54.640 align:middle
引用符を 2 つ書き込んでも
それは  1 文字として扱われます。

00:02:56.800 --> 00:03:01.240 align:middle
文字列は他のコレクションと同じように
扱うことができます。

00:03:01.400 --> 00:03:05.440 align:middle
文字列の最後の要素を得るためには

00:03:05.600 --> 00:03:10.320 align:middle
str at: str size
とすることができます。

00:03:10.480 --> 00:03:13.960 align:middle
忘れてはいけないのは、Pharo では
インデックスが 1 から始まることです。

00:03:14.120 --> 00:03:17.400 align:middle
したがって、文字列のサイズが
最後の文字のインデックスになります。

00:03:17.640 --> 00:03:22.320 align:middle
あるいは、単に last を送ることで
最後の要素を得ることができます。

00:03:22.840 --> 00:03:26.200 align:middle
文字列を生成するためには
いろいろなやり方があります。

00:03:26.360 --> 00:03:29.760 align:middle
簡単なのは変換メソッドを使うことです。

00:03:29.920 --> 00:03:33.560 align:middle
シンボルを文字列に変換するには
asString メッセージを使います。

00:03:33.720 --> 00:03:36.960 align:middle
あるいは、どんなオブジェクトに対しても
printString を送ることができます。

00:03:37.120 --> 00:03:41.200 align:middle
すると、そのオブジェクトの
文字列表現が得られます。

00:03:42.400 --> 00:03:46.240 align:middle
あるいは、コレクション生成メソッドを
直接使ううことで文字列を生成できます。

00:03:46.400 --> 00:03:49.840 align:middle
任意のコレクションクラスに
with: を送ることで

00:03:50.000 --> 00:03:54.640 align:middle
引数として渡した要素を含むコレクションを
生成することができます。覚えていますよね。

00:03:54.800 --> 00:03:56.600 align:middle
String with: $A
とすると

00:03:56.760 --> 00:04:00.520 align:middle
1 文字「A」からなる文字列が得られます。

00:04:00.680 --> 00:04:02.120 align:middle
文字列を連結するためには

00:04:02.280 --> 00:04:05.640 align:middle
もう見たと思いますが、コンマを使います。

00:04:05.800 --> 00:04:09.640 align:middle
「,」を文字列に送って
引数として文字列を渡すと

00:04:09.800 --> 00:04:13.800 align:middle
それら 2 つの文字列を連結した
新しい文字列を生成します。

00:04:14.560 --> 00:04:16.160 align:middle
ただし、気をつけなければならないのは

00:04:16.320 --> 00:04:19.400 align:middle
この例のようなことをすると

00:04:19.560 --> 00:04:23.440 align:middle
無用な中間生成物をつくってしまう
ということを忘れないでください。

00:04:23.600 --> 00:04:27.440 align:middle
つまり、この文字列に
最初の , メッセージを

00:04:27.600 --> 00:04:30.120 align:middle
この引数で送ると

00:04:30.280 --> 00:04:34.600 align:middle
最初の連結文字列が生成されます。

00:04:34.920 --> 00:04:38.800 align:middle
この連結文字列に , を送ると

00:04:38.960 --> 00:04:41.680 align:middle
また別の連結文字列が生成されて
それが最終的な返り値になります。

00:04:41.840 --> 00:04:45.280 align:middle
中間文字列が生成されてしまい

00:04:45.440 --> 00:04:48.680 align:middle
計算時間の無駄になります。

00:04:48.840 --> 00:04:51.560 align:middle
ベンチマークの講義がありましたね。

00:04:51.720 --> 00:04:55.840 align:middle
何が起こっているのか
ベンチマークで見て

00:04:56.000 --> 00:04:59.240 align:middle
そしてストリームを使うべきか
判断してください。

00:04:59.400 --> 00:05:02.000 align:middle
文字列を生成するために

00:05:02.160 --> 00:05:06.000 align:middle
streamContents: を使って

00:05:06.160 --> 00:05:11.320 align:middle
このストリームに文字を直接送り込んで
最終的な文字列を生成することができます。

00:05:11.480 --> 00:05:14.200 align:middle
この方法を使うと、文字列が中間生成される
のを避けることができます。

00:05:14.360 --> 00:05:16.760 align:middle
さて、シンボルですが

00:05:16.920 --> 00:05:21.200 align:middle
構文的には
シンボルはハッシュタグで始まります。

00:05:21.360 --> 00:05:23.120 align:middle
そして文字列が続きます。

00:05:23.280 --> 00:05:24.880 align:middle
これがシンボルのリテラルです。

00:05:25.040 --> 00:05:29.760 align:middle
これはある種の文字列ですが
システム内でユニークな文字列です。

00:05:29.920 --> 00:05:33.200 align:middle
プログラムのどこかで
ハッシュタグに続いて「ほげほげ」書くと

00:05:33.360 --> 00:05:36.320 align:middle
プログラム中の他の箇所での
ハッシュタグ「ほげほげ」は

00:05:36.480 --> 00:05:38.760 align:middle
同一のオブジェクトを指すことになります。

00:05:38.920 --> 00:05:40.680 align:middle
同じインスタンスを指すということです。

00:05:41.400 --> 00:05:43.640 align:middle
これがシンボルはユニークということです。

00:05:43.800 --> 00:05:48.480 align:middle
ここに #calvin == #calvin とありますが
true になります。

00:05:48.640 --> 00:05:50.120 align:middle
同一オブジェクトということです。

00:05:50.280 --> 00:05:53.760 align:middle
文字列の場合はそうはなりません。
場合によります。

00:05:53.920 --> 00:05:57.000 align:middle
コンパイラの最適化によって
変わってきます。

00:05:57.400 --> 00:06:01.440 align:middle
これがシンボルと文字列の違いです。

00:06:01.600 --> 00:06:05.360 align:middle
シンボルは完全にリードオンリーです。

00:06:05.520 --> 00:06:08.600 align:middle
シンボルは書き換えることができません。
新しいシンボルを生成する必要があります。

00:06:08.760 --> 00:06:13.080 align:middle
シンボルはユニークなオブジェクト
つまり常に同じオブジェクトを指します。

00:06:13.240 --> 00:06:17.440 align:middle
文字列はミュータブルなオブジェクトで
内容を書き換えることができます。

00:06:17.600 --> 00:06:22.440 align:middle
今のところは。実際のところ
現在まだ議論の対象になっています。

00:06:24.080 --> 00:06:26.440 align:middle
シンボルはメソッドセレクターとして

00:06:27.560 --> 00:06:30.320 align:middle
よく使われます。

00:06:31.480 --> 00:06:35.160 align:middle
そしてシンボルは辞書（Dictionary）の

00:06:35.320 --> 00:06:37.160 align:middle
キーとして有用です。

00:06:37.320 --> 00:06:39.080 align:middle
IdentityDictionary を

00:06:39.240 --> 00:06:40.560 align:middle
知っていますか？

00:06:40.720 --> 00:06:43.160 align:middle
辞書のキーとして使うと

00:06:43.320 --> 00:06:48.600 align:middle
比較のためにハッシュを計算して

00:06:48.760 --> 00:06:51.200 align:middle
辞書の中に格納します。

00:06:52.680 --> 00:06:56.360 align:middle
この講義で重要なことは

00:06:56.520 --> 00:07:00.120 align:middle
文字列は他のコレクションと同様であること

00:07:00.280 --> 00:07:03.360 align:middle
そしてシンボルはユニークであり

00:07:03.520 --> 00:07:06.320 align:middle
リードオンリーで
イミュータブルであることです。

