WEBVTT

00:00:00.520 --> 00:00:04.760 align:middle
今日はもう1つの復習をします。

00:00:04.920 --> 00:00:06.880 align:middle
もう前にやりましたが

00:00:07.040 --> 00:00:12.000 align:middle
リテラルと動的配列の違い
についてです。

00:00:13.080 --> 00:00:15.000 align:middle
今回学ぶことは

00:00:15.160 --> 00:00:18.160 align:middle
リテラル配列はメッセージ送信で
作られるものではなく

00:00:18.320 --> 00:00:23.560 align:middle
動的配列は実行時にメッセージを使って
作られます。

00:00:23.720 --> 00:00:26.600 align:middle
しかし、どちらも
Array クラスのインスタンスです。

00:00:26.760 --> 00:00:29.560 align:middle
配列を作るための方法が
2 つあるということです。

00:00:30.000 --> 00:00:31.440 align:middle
覚えているでしょうか

00:00:31.600 --> 00:00:36.080 align:middle
リテラル配列を作る構文は
#( に続いて

00:00:36.240 --> 00:00:40.280 align:middle
テキスト形式のオブジェクトを
入れていきます。

00:00:40.440 --> 00:00:43.600 align:middle
この場合、整数 45 と
文字列「milou」と

00:00:44.000 --> 00:00:46.600 align:middle
数 1300と真偽値 true と

00:00:46.760 --> 00:00:48.760 align:middle
シンボル #tintin です。

00:00:49.600 --> 00:00:53.680 align:middle
このリテラルオブジェクトにクラスを
尋ねれば

00:00:53.840 --> 00:00:56.600 align:middle
Array のインスタンスだと答えます。

00:00:56.960 --> 00:00:59.760 align:middle
このリテラル配列の動的なバージョンが

00:00:59.920 --> 00:01:03.440 align:middle
これです。

00:01:03.720 --> 00:01:07.160 align:middle
動的配列を生成するには
Array クラスを使って

00:01:07.320 --> 00:01:11.160 align:middle
with:with:with:with: メソッドで
インスタンスを生成します。

00:01:11.320 --> 00:01:14.160 align:middle
メッセージをこれらを引数にして渡して

00:01:14.320 --> 00:01:18.480 align:middle
上のリテラル配列と等しい
Array クラスのインスタンスを生成します。

00:01:18.640 --> 00:01:21.720 align:middle
オブジェクトを生成する方法が
2 つあるということです。

00:01:22.640 --> 00:01:25.600 align:middle
これはまた別のバージョンの
動的配列です。

00:01:25.760 --> 00:01:29.200 align:middle
Array クラスに new: メッセージを送って

00:01:29.360 --> 00:01:32.480 align:middle
配列を手動で作ることができます。

00:01:32.640 --> 00:01:37.200 align:middle
そして at:put: を使って
配列の内容を埋めていって

00:01:37.360 --> 00:01:38.880 align:middle
できあがった配列を返します。

00:01:39.040 --> 00:01:42.240 align:middle
これも動的配列を作るための
さらにもう1つ別の方法です。

00:01:42.560 --> 00:01:46.960 align:middle
中括弧を使った

00:01:47.120 --> 00:01:49.320 align:middle
専用の構文糖衣を使うやり方です。

00:01:49.880 --> 00:01:50.880 align:middle
いいですか？

00:01:51.040 --> 00:01:55.880 align:middle
この中括弧を使って上に書いたのと
全く同じ配列を

00:01:56.040 --> 00:01:59.320 align:middle
より速くかつ明快に書くことができます。

00:02:00.120 --> 00:02:01.800 align:middle
できあがるものは同じです。

00:02:02.080 --> 00:02:05.440 align:middle
つまり、中括弧の中に

00:02:05.600 --> 00:02:08.680 align:middle
表現式を点（.）で区切って
入れておくと

00:02:08.840 --> 00:02:11.520 align:middle
それらの表現式が評価されて
コレクションが作られます。

00:02:11.680 --> 00:02:13.360 align:middle
リテラル配列と

00:02:13.520 --> 00:02:16.000 align:middle
中括弧による動的配列の

00:02:16.160 --> 00:02:20.920 align:middle
大きな違いは

00:02:21.080 --> 00:02:24.280 align:middle
表現式として

00:02:24.440 --> 00:02:28.160 align:middle
例えば 12 に初期化された変数で

00:02:28.320 --> 00:02:33.640 align:middle
配列を作る時には
リテラル配列の場合には #( に続いて

00:02:33.800 --> 00:02:36.240 align:middle
a + 1. 13

00:02:36.400 --> 00:02:38.320 align:middle
とすると、こんな配列になります。

00:02:38.720 --> 00:02:42.160 align:middle
つまり シンボル a と + と

00:02:42.320 --> 00:02:45.520 align:middle
整数 1 とシンボル . と整数13
から成る配列です。

00:02:45.680 --> 00:02:48.480 align:middle
動的配列で同じことをすると

00:02:48.640 --> 00:02:50.120 align:middle
a := 12
に続いて

00:02:50.480 --> 00:02:53.000 align:middle
{ a + 1. 13 }
とすると

00:02:53.160 --> 00:02:56.120 align:middle
2 つの要素から成る配列が得られます。

00:02:56.520 --> 00:02:58.000 align:middle
要素は 13 と 13 です。

00:02:58.240 --> 00:02:59.240 align:middle
どういうことかというと

00:02:59.400 --> 00:03:03.600 align:middle
a + 1 が表現式として評価され

00:03:03.760 --> 00:03:06.600 align:middle
a は 12 で、それに + 1
そして次が 13

00:03:06.760 --> 00:03:10.240 align:middle
点（.）で区切られた各表現式が
評価されてから

00:03:10.400 --> 00:03:12.120 align:middle
配列が生成されます。

00:03:12.880 --> 00:03:15.880 align:middle
つまり、重要な違いは

00:03:16.040 --> 00:03:18.600 align:middle
中括弧を使うと
式が実行されて

00:03:18.760 --> 00:03:22.240 align:middle
#( を使ってリテラル配列をつくると

00:03:22.400 --> 00:03:25.760 align:middle
式は実行されません。

00:03:25.920 --> 00:03:27.200 align:middle
なぜかというと

00:03:28.040 --> 00:03:32.720 align:middle
リテラル配列を生成するのは

00:03:32.880 --> 00:03:34.880 align:middle
コンパイラだからです。

00:03:35.200 --> 00:03:39.080 align:middle
もう少し複雑な例があります。

00:03:39.240 --> 00:03:41.360 align:middle
#( に続いて

00:03:41.520 --> 00:03:44.760 align:middle
さらに内部で括弧を使います。
ここがポイントなのですが

00:03:44.920 --> 00:03:48.800 align:middle
リテラル配列の中で括弧を使うことで
ネストしたリテラル配列を作ります。

00:03:48.960 --> 00:03:53.760 align:middle
このリテラル配列では
何も評価実行されません。

00:03:53.920 --> 00:03:57.440 align:middle
コンパイル時にコンパイラが作るからです。

00:03:57.600 --> 00:04:02.160 align:middle
ネストした配列を含む配列が 1 つできます。

00:04:02.560 --> 00:04:04.440 align:middle
ここにあるように

00:04:06.520 --> 00:04:09.240 align:middle
1 つ目のネスト配列の内容は

00:04:09.400 --> 00:04:13.920 align:middle
10 とシンボル @ と整数 20 などです。

00:04:14.080 --> 00:04:17.680 align:middle
その証拠に
この配列の 1 番目の要素を取り出すと

00:04:17.840 --> 00:04:19.560 align:middle
この配列が得られます。

00:04:20.160 --> 00:04:23.000 align:middle
リテラル配列の中で括弧を使うと

00:04:23.160 --> 00:04:25.200 align:middle
ネストした配列ができます。

00:04:26.240 --> 00:04:28.120 align:middle
重要なことは

00:04:28.280 --> 00:04:31.800 align:middle
Pharo では配列は
1 種類しかないということです。

00:04:31.960 --> 00:04:34.400 align:middle
Array クラスのインスタンスです。

00:04:34.560 --> 00:04:38.440 align:middle
しかし配列を生成する方法は色々あります。

00:04:38.600 --> 00:04:42.520 align:middle
1 つ目の方法はリテラル構文
#( です。

00:04:42.680 --> 00:04:47.000 align:middle
この場合、配列はコンパイル時に
コンパイラが生成することに注意してください。

00:04:47.240 --> 00:04:50.000 align:middle
動的な方法で簡単なのは
Array new: です。

00:04:50.160 --> 00:04:53.160 align:middle
new: メッセージを
Array クラスに送ります。

00:04:53.320 --> 00:04:57.920 align:middle
構文的にコンパクトな動的な方法は

00:04:58.080 --> 00:05:02.880 align:middle
中括弧を使って表現式を点で区切って

00:05:03.040 --> 00:05:05.720 align:middle
それぞれ評価して配列を生成します。

