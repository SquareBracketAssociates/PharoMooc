1
00:00:00,520 --> 00:00:04,760
今日はもう1つの復習をします。

2
00:00:04,920 --> 00:00:06,880
もう前にやりましたが

3
00:00:07,040 --> 00:00:12,000
リテラルと動的配列の違い
についてです。

4
00:00:13,080 --> 00:00:15,000
今回学ぶことは

5
00:00:15,160 --> 00:00:18,160
リテラル配列はメッセージ送信で
作られるものではなく

6
00:00:18,320 --> 00:00:23,560
動的配列は実行時にメッセージを使って
作られます。

7
00:00:23,720 --> 00:00:26,600
しかし、どちらも
Array クラスのインスタンスです。

8
00:00:26,760 --> 00:00:29,560
配列を作るための方法が
2 つあるということです。

9
00:00:30,000 --> 00:00:31,440
覚えているでしょうか

10
00:00:31,600 --> 00:00:36,080
リテラル配列を作る構文は
#( に続いて

11
00:00:36,240 --> 00:00:40,280
テキスト形式のオブジェクトを
入れていきます。

12
00:00:40,440 --> 00:00:43,600
この場合、整数 45 と
文字列「milou」と

13
00:00:44,000 --> 00:00:46,600
数 1300と真偽値 true と

14
00:00:46,760 --> 00:00:48,760
シンボル #tintin です。

15
00:00:49,600 --> 00:00:53,680
このリテラルオブジェクトにクラスを
尋ねれば

16
00:00:53,840 --> 00:00:56,600
Array のインスタンスだと答えます。

17
00:00:56,960 --> 00:00:59,760
このリテラル配列の動的なバージョンが

18
00:00:59,920 --> 00:01:03,440
これです。

19
00:01:03,720 --> 00:01:07,160
動的配列を生成するには
Array クラスを使って

20
00:01:07,320 --> 00:01:11,160
with:with:with:with: メソッドで
インスタンスを生成します。

21
00:01:11,320 --> 00:01:14,160
メッセージをこれらを引数にして渡して

22
00:01:14,320 --> 00:01:18,480
上のリテラル配列と等しい
Array クラスのインスタンスを生成します。

23
00:01:18,640 --> 00:01:21,720
オブジェクトを生成する方法が
2 つあるということです。

24
00:01:22,640 --> 00:01:25,600
これはまた別のバージョンの
動的配列です。

25
00:01:25,760 --> 00:01:29,200
Array クラスに new: メッセージを送って

26
00:01:29,360 --> 00:01:32,480
配列を手動で作ることができます。

27
00:01:32,640 --> 00:01:37,200
そして at:put: を使って
配列の内容を埋めていって

28
00:01:37,360 --> 00:01:38,880
できあがった配列を返します。

29
00:01:39,040 --> 00:01:42,240
これも動的配列を作るための
さらにもう1つ別の方法です。

30
00:01:42,560 --> 00:01:46,960
中括弧を使った

31
00:01:47,120 --> 00:01:49,320
専用の構文糖衣を使うやり方です。

32
00:01:49,880 --> 00:01:50,880
いいですか？

33
00:01:51,040 --> 00:01:55,880
この中括弧を使って上に書いたのと
全く同じ配列を

34
00:01:56,040 --> 00:01:59,320
より速くかつ明快に書くことができます。

35
00:02:00,120 --> 00:02:01,800
できあがるものは同じです。

36
00:02:02,080 --> 00:02:05,440
つまり、中括弧の中に

37
00:02:05,600 --> 00:02:08,680
表現式を点（.）で区切って
入れておくと

38
00:02:08,840 --> 00:02:11,520
それらの表現式が評価されて
コレクションが作られます。

39
00:02:11,680 --> 00:02:13,360
リテラル配列と

40
00:02:13,520 --> 00:02:16,000
中括弧による動的配列の

41
00:02:16,160 --> 00:02:20,920
大きな違いは

42
00:02:21,080 --> 00:02:24,280
表現式として

43
00:02:24,440 --> 00:02:28,160
例えば 12 に初期化された変数で

44
00:02:28,320 --> 00:02:33,640
配列を作る時には
リテラル配列の場合には #( に続いて

45
00:02:33,800 --> 00:02:36,240
a + 1. 13

46
00:02:36,400 --> 00:02:38,320
とすると、こんな配列になります。

47
00:02:38,720 --> 00:02:42,160
つまり シンボル a と + と

48
00:02:42,320 --> 00:02:45,520
整数 1 とシンボル . と整数13
から成る配列です。

49
00:02:45,680 --> 00:02:48,480
動的配列で同じことをすると

50
00:02:48,640 --> 00:02:50,120
a := 12
に続いて

51
00:02:50,480 --> 00:02:53,000
{ a + 1. 13 }
とすると

52
00:02:53,160 --> 00:02:56,120
2 つの要素から成る配列が得られます。

53
00:02:56,520 --> 00:02:58,000
要素は 13 と 13 です。

54
00:02:58,240 --> 00:02:59,240
どういうことかというと

55
00:02:59,400 --> 00:03:03,600
a + 1 が表現式として評価され

56
00:03:03,760 --> 00:03:06,600
a は 12 で、それに + 1
そして次が 13

57
00:03:06,760 --> 00:03:10,240
点（.）で区切られた各表現式が
評価されてから

58
00:03:10,400 --> 00:03:12,120
配列が生成されます。

59
00:03:12,880 --> 00:03:15,880
つまり、重要な違いは

60
00:03:16,040 --> 00:03:18,600
中括弧を使うと
式が実行されて

61
00:03:18,760 --> 00:03:22,240
#( を使ってリテラル配列をつくると

62
00:03:22,400 --> 00:03:25,760
式は実行されません。

63
00:03:25,920 --> 00:03:27,200
なぜかというと

64
00:03:28,040 --> 00:03:32,720
リテラル配列を生成するのは

65
00:03:32,880 --> 00:03:34,880
コンパイラだからです。

66
00:03:35,200 --> 00:03:39,080
もう少し複雑な例があります。

67
00:03:39,240 --> 00:03:41,360
#( に続いて

68
00:03:41,520 --> 00:03:44,760
さらに内部で括弧を使います。
ここがポイントなのですが

69
00:03:44,920 --> 00:03:48,800
リテラル配列の中で括弧を使うことで
ネストしたリテラル配列を作ります。

70
00:03:48,960 --> 00:03:53,760
このリテラル配列では
何も評価実行されません。

71
00:03:53,920 --> 00:03:57,440
コンパイル時にコンパイラが作るからです。

72
00:03:57,600 --> 00:04:02,160
ネストした配列を含む配列が 1 つできます。

73
00:04:02,560 --> 00:04:04,440
ここにあるように

74
00:04:06,520 --> 00:04:09,240
1 つ目のネスト配列の内容は

75
00:04:09,400 --> 00:04:13,920
10 とシンボル @ と整数 20 などです。

76
00:04:14,080 --> 00:04:17,680
その証拠に
この配列の 1 番目の要素を取り出すと

77
00:04:17,840 --> 00:04:19,560
この配列が得られます。

78
00:04:20,160 --> 00:04:23,000
リテラル配列の中で括弧を使うと

79
00:04:23,160 --> 00:04:25,200
ネストした配列ができます。

80
00:04:26,240 --> 00:04:28,120
重要なことは

81
00:04:28,280 --> 00:04:31,800
Pharo では配列は
1 種類しかないということです。

82
00:04:31,960 --> 00:04:34,400
Array クラスのインスタンスです。

83
00:04:34,560 --> 00:04:38,440
しかし配列を生成する方法は色々あります。

84
00:04:38,600 --> 00:04:42,520
1 つ目の方法はリテラル構文
#( です。

85
00:04:42,680 --> 00:04:47,000
この場合、配列はコンパイル時に
コンパイラが生成することに注意してください。

86
00:04:47,240 --> 00:04:50,000
動的な方法で簡単なのは
Array new: です。

87
00:04:50,160 --> 00:04:53,160
new: メッセージを
Array クラスに送ります。

88
00:04:53,320 --> 00:04:57,920
構文的にコンパクトな動的な方法は

89
00:04:58,080 --> 00:05:02,880
中括弧を使って表現式を点で区切って

90
00:05:03,040 --> 00:05:05,720
それぞれ評価して配列を生成します。